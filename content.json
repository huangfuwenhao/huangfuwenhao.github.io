{"meta":{"title":"皇甫文豪'S BLOG","subtitle":"江上之清风，山间之明月","description":"书犹药也，善读之可以医愚。— — (汉)刘向","author":"YACHU","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-04-18T12:33:52.000Z","updated":"2018-04-18T12:36:35.060Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About me","date":"2017-04-27T13:29:25.000Z","updated":"2020-04-05T09:09:12.360Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"作者简介：个人信息姓名：皇甫文豪，男，90 后。籍贯：河南省。职业：WEB 前端工程师。2013 年 9 月至 2017 年 6 月就读于周口师范学院全日制本科软件工程专业。 三年前端开发经验，掌握前端基本功，熟悉常用的前端技术及工具，擅长 Vue。 主修课程：数据结构、计算机网络，操作系统，计算机组成原理，网页设计与开发，C# 高级程序设计，SQL Server 数据库等。 技术特长： 熟练掌握 HTML、CSS 网页布局技术。 掌握 CSS 预处理语言 Less 。 对移动端布局有一定了解，熟悉 Rem 布局，Flex 布局，流式布局，响应式布局等。 熟悉前端 UI 框架 Bootstrap、MUI。 掌握 JavaScript 的原型链，继承，闭包，递归等。 熟悉 jQuery，Lodash，Zepto 等常用 JavaScript 库。 掌握原生 Ajax 请求，熟悉 HTTP 协议。能使用 Art-Template 模板快速渲染数据。 了解浏览器同源策略，能使用 JSONP，Nginx 等解决跨域问题。 理解面向对象思想，对前端的模块化和组件化有一定了解。 熟悉 HTML5，CSS3 新特性及 ECMAScript 6 常用语法。 掌握 Vue 全家桶及其组件库 Element-UI 的使用。熟悉 Axios 的使用。 熟悉 React 的基本使用，熟悉 Styled components 样式组件和 Next.js 服务端渲染。 熟练使用 Webpack 进行项目的构建与打包，了解 gulp 。 熟练使用 Git 版本控制工具进行代码管理。熟悉 NPM 包管理器。 熟悉微信公众号和微信小程序开发。 熟悉 uni-app 跨端开发框架，可跨端开发小程序和 hybrid app 等。 熟悉前端 Excel 框架 SpreadJS。熟悉 appCan 开发 Hybrid app。 熟悉 Layui 框架，熟悉 CoreUI，使用过 CureUI/Vue 开发过项目。 了解 Node.js 及其框架 Express。 寄语自己：我对 Web 前端开发有着浓厚的兴趣，我相信科技改变生活，希望通过前端技术为改善互联网的用户体验出一份力。我也希望能在技术分享这一块做出自己的一些贡献，希望通过博客来分享自己的学习经验，分享项目开发中所遇到问题以及解决方案，所以建立了自己的个人博客网站，希冀为前端行业的进步与发展贡献自己的一点绵薄之力。同时我热爱骑行，喜欢团队协作去挑战困难的热烈氛围。曾于 2015 年 7 月从河南周口出发，历时近一个月骑行进入西藏。后又在 2019 年 8 月再次由大理自滇藏线骑行至拉萨。 联系方式：个人邮箱：huangfuwh@163.com"},{"title":"分类","date":"2018-04-18T12:32:09.000Z","updated":"2018-04-18T12:36:41.050Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？","slug":"使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？","date":"2020-04-05T17:00:00.000Z","updated":"2020-04-06T06:35:17.667Z","comments":true,"path":"2020/04/06/使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？/","link":"","permalink":"http://yoursite.com/2020/04/06/使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？/","excerpt":"","text":"前情提要这几天在使用 vue-cli 创建 vue 项目时，竟然忘记 runtime-only 运行时和 runtime + compiler 完整版的区别了，查过官网文档后，记下这篇笔记。 注：以下内容摘自官网。 runtime-only术语完整版：同时包含编译器和运行时的版本。 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 对于 Vue 不同构建版本的区别，可访问 Vue 官网查看 Vue 对不同构建版本的解释 运行时 + 编译器 vs. 只包含运行时如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版： 12345678910// 需要编译器new Vue(&#123; template: &apos;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&apos;&#125;)// 不需要编译器new Vue(&#123; render (h) &#123; return h(&apos;div&apos;, this.hi) &#125;&#125;) 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"}]},{"title":"lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别","slug":"lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T06:35:13.384Z","comments":true,"path":"2020/04/06/lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别/","link":"","permalink":"http://yoursite.com/2020/04/06/lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别/","excerpt":"","text":"_.debounce() 和 _.throttle()防抖：语法 _.debounce(func, [wait=0], [options={}]) 创建一个防抖动函数。会从上一次调用结束后延迟 wait 毫秒后继续调用 func 方法，该函数提供一个 cancel 方法以供取消延迟函数的调用以及 flush 方法立即调用。 options 对象这个参数决定了怎么调用 func 函数。options.leading 与（或） options.trailing 决定延迟（wait）前，func 如何调用（也就是先调用再等待还是先等待再调用）。func 会传入最后一次传递的参数给 debounce 这个函数。随后调用的 debounce 函数返回的是最后一次 func 调用的结果。 注意：如果 leading 和 trailing 都为 true，则 func 允许的 trailing 调用条件为 wait 期间多次调用 debounce 防抖方法。如果 wait 为 0 并且 leading 为 false, func 调用将被推迟到下一个点，类似 setTimeout 为 0 的超时。 参数： func: 需要防抖的函数 wait(number): 毫秒数 opotions(object): 选项对象 options.leading(boolean): 调用在防抖开始前。 options.trailing(boolean): 调用在防抖结束后。 options.maxWait(number): 允许 func 被延迟的最大毫秒数。 返回值：返回新的防抖动函数。 示例代码请看官网：lodash 之 debounce 节流：语法 _.throttle(func, [wait=0], [options={}]) throttle() 方法创建一个节流函数，意为在 wait 秒内最多执行一次 func 函数。该函数同时提供一个 cancel 方法以供取消延迟函数的调用以及 flush 方法立即调用。 options 对象这个参数决定了怎么调用 func 函数。options.leading 与（或） options.trailing 决定延迟（wait）前，func 如何调用。func 会传入最后一次传递的参数给这个函数。随后调用的函数返回的是最后一次 func 调用的结果。 注意：如果 leading 和 trailing 都为 true，则 func 允许的 trailing 调用条件为 wait 期间多次调用。如果 wait 为 0 并且 leading 为 false, func 调用将被推迟到下一个点，类似 setTimeout 为 0 的超时。 参数： func: 需要节流的函数 wait(number): 毫秒数 opotions(object): 选项对象 options.leading(boolean): 调用在节流开始前。 options.trailing(boolean): 调用在节流结束后。 返回值：返回节流的函数。 123456789101112131415// 避免在滚动时过分的更新定位$(window).on(&quot;scroll&quot;, _.throttle(updatePosition, 500));function updatePosition() &#123; // 假装在更新定位 console.log(1);&#125;// 点击后就调用 renewToken， 但 5 分钟内超过一次var throttled = _.throttle(renewToken, 300000, &#123; trailing: false &#125;);$(ele).on(&quot;click&quot;, throttled);// 取消一个 trailing 的节流调用$(window).on(&quot;popstate&quot;, throttled.cancel);function renewToken() &#123; // 假装在请求更新 token console.log(2);&#125; _.debounce() 和 _.throttle() 的 api 介绍和使用方法取自官网，加了一点修饰。 防抖和节流的区别防抖:把突然爆发的事件(比如点击事件)组合成一个单一的事件。场景应用： 浏览器的 resize 事件，借助防抖我们只需要关注用户拖动窗口的最后一次的值。 比如用户输入内容时，使用防抖只在用户停止输入时触发事件。 类似的用例是等到用户停止输入之后再验证其输入值。 提示“您的密码太短”之类的消息。 节流：保证每 x 毫秒执行一次函数，它是恒定的流量。场景应用： 比如每 200 毫秒检查一次你的滚动位置来触发一个 CSS 动画。 比如上滑加载，我们需要检测用户距离底部多远，当用户接近底部时，我们需要发送 ajax 请求数据回来。在这里，防抖没用，因为它只在用户停止滚动时触发，而我们需要在用户到达底部之前获取数据。而节流可以让我们不停检测距离底部多远？节流可以保证函数有规律地执行，至少每 x 毫秒执行一次。 防抖和节流的区别总结和翻译自下面这篇文章，更多详细信息可访问 David Corbacho’s article 查看 _.debounce 函数防抖和 _.throttle 函数节流的区别 小技巧如果你只需要防抖和节流函数，您可以使用 Lodash 自定义构建器输出一个自定义的 2KB 最小化库。 用下面这个简单的命令构建它: 12npm i -g lodash-clilodash include = debounce, throttle","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"lodash","slug":"lodash","permalink":"http://yoursite.com/tags/lodash/"}]},{"title":"数组方法之reduce()","slug":"数组方法之 reduce","date":"2020-04-04T17:50:09.000Z","updated":"2020-04-06T06:37:02.879Z","comments":true,"path":"2020/04/05/数组方法之 reduce/","link":"","permalink":"http://yoursite.com/2020/04/05/数组方法之 reduce/","excerpt":"","text":"reduce() 方法对数组的每个元素依次执行自定义回调函数，返回值为回调函数 return 的处理结果。先看一个示例： 1234const arr = [1, 2, 3, 4];const reduceFn = (accumulator, currentVal) =&gt; accumulator + currentVal;console.log(arr.reduce(reduceFn));// 10console.log(arr.reduce(reduceFn, 5));// 15 语法： arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数方法接收两个参数： callback() 回调函数。其接收四个参数： accumulator：累计器，累计回调函数的值。 current value：当前值。 current index： 当前值的索引。（可选） souce map: 源数组，也就是调用 reduce() 方法的数组。（可选） initVal: 初始值。（可选） 返回值回调函数累计处理的结果。 注意 如果传递 initVal，则 accumulator 累计器为 initVal, 不传递则为数组的第一项。 currentVal 当前值为数组第一项，不传递则为数组第二项。 currentIndex 当前索引为数组第一项的索引 0，不传递则为 1。 当给空数组调用 reduce 方法，且不传递初始值时，将报错。如果数组仅有一个元素，且没有提供初始值，或者提供了初始值，但数组为空，会将唯一值返回，并且 callback 不再执行。 更多 reduce 的使用示例可访问 MDN 之 reduce","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"JavaScript Array reduce","slug":"JavaScript-Array-reduce","permalink":"http://yoursite.com/tags/JavaScript-Array-reduce/"}]},{"title":"Vue.js 响应式的注意事项","slug":"Vue.js 响应式的注意事项","date":"2020-04-04T16:50:09.000Z","updated":"2020-04-05T09:51:21.928Z","comments":true,"path":"2020/04/05/Vue.js 响应式的注意事项/","link":"","permalink":"http://yoursite.com/2020/04/05/Vue.js 响应式的注意事项/","excerpt":"数组更新检测注意事项由于 JS 的限制，下列情形数组的更新不能被检测到。 使用数组下标设置一个数组项时 操作数组长度时 1234567var vm = new Vue(&#123; data: &#123; arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;&#125;)vm.arr[1] = &apos;x&apos;; // 不是响应式vm.arr.length = 2; // 不是响应式","text":"数组更新检测注意事项由于 JS 的限制，下列情形数组的更新不能被检测到。 使用数组下标设置一个数组项时 操作数组长度时 1234567var vm = new Vue(&#123; data: &#123; arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;&#125;)vm.arr[1] = &apos;x&apos;; // 不是响应式vm.arr.length = 2; // 不是响应式 对于第一种情况，可以使用 Vue.set() 方法和 vm.$set() 方法（vm.$set() 方法其实就是 Vue.set() 全局方法的别名）。同时可以使用 splice() 实现。 123Vue.set(vm.arr, 1, &apos;x&apos;)vm.$set(vm.arr, 1, &apos;x&apos;)vm.arr.splice(1, 1, &apos;x&apos;) 对于第二种情况也可以使用 splice() 方法实现。 1vm.arr.splice(2) 官网链接如下：数组更新方法-注意事项&gt;) 对象更新检测注意事项还是由于 JS 限制，Vue 不能检测对象属性的添加和删除。 12345678910var vm = new Vue(&#123; data: &#123; userInfo: &#123; name: &apos;简宝玉&apos; &#125; &#125;&#125;)// userInfo.name 响应式vm.userInfo.age = 17// userInfo.age 非响应式 同样，你可以使用 Vue.set() 和 vm.\\$set() 解决这个问题。 12Vue.set(vm.userInfo, age, 17)vm.$set(vm.userInfo, age, 17) 当你需要添加多个属性时，正确操作是使用 Object.assign() 或者 lodash 的 extend() 方法。 1234vm.userInfo = Object.assign(&#123;&#125;,vm.userInfo,&#123; age: 17, sex: &apos;男‘&#125;)","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Vue.js 之“变异”和“替换”的概念","slug":"Vue.js 之“变异”和“替换”的概念","date":"2020-04-04T16:35:18.000Z","updated":"2020-04-05T09:51:04.209Z","comments":true,"path":"2020/04/05/Vue.js 之“变异”和“替换”的概念/","link":"","permalink":"http://yoursite.com/2020/04/05/Vue.js 之“变异”和“替换”的概念/","excerpt":"前言今天在翻阅 Vue 的文档查看 watch 相关解释时，在查看到 vm.\\$watch 时看到了“变异”一词。官网内容摘抄如下： 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 当时内心充满了困惑，当真是不小的朋友也有很多问号？明明是我认识的词语，却又那么陌生。为了理解“变异”一词的意思，写下这篇文章。 什么是变异？ 变异方法，顾名思义，会改变调用了这些方法的原始数组。 数组的变异方法包括 push(), pop(), shift(), unshift(), splice(), sort(), reverse()。这些变异方法也会触发视图更新。","text":"前言今天在翻阅 Vue 的文档查看 watch 相关解释时，在查看到 vm.\\$watch 时看到了“变异”一词。官网内容摘抄如下： 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 当时内心充满了困惑，当真是不小的朋友也有很多问号？明明是我认识的词语，却又那么陌生。为了理解“变异”一词的意思，写下这篇文章。 什么是变异？ 变异方法，顾名思义，会改变调用了这些方法的原始数组。 数组的变异方法包括 push(), pop(), shift(), unshift(), splice(), sort(), reverse()。这些变异方法也会触发视图更新。 什么是替换？非变异方法也就是不会改变原数组，而总是返回一个新数组。例如：filter(), concat(), slice()等。当使用非变异方法时，可以直接替换数组。 1this.userList = this.userList.filter(item =&gt; item.age &gt; 18) 基于 Vue 的设计，这并不会导致整个列表被重新渲染，因而可以使用替换。 结语看到这里也就明白了，变异的情形就是变异方法会改变原数组。替换的情形就是非变异方法不改变原数组，返回新数组，加上 Vue 的设计，可以使用替换操作。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？","slug":"Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？","date":"2020-04-03T16:00:00.000Z","updated":"2020-04-05T09:44:42.442Z","comments":true,"path":"2020/04/04/Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？/","link":"","permalink":"http://yoursite.com/2020/04/04/Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？/","excerpt":"为什么写这篇笔记？记得在以往的面试中多次被问到这个问题，回答的都不理想，仔细想想也是理解的不到位。今天借着休息的时间准备查阅文档，写写示例代码去仔细理解下。 computed 计算属性是什么？computed 计算属性介绍：computed 计算属性是一个对象。它的使用方法是在 computed 属性中定义一个方法，和给对象定义方法一样，方法名可以直接在页面（template）中使用，不需要加 （），这是因为计算属性看起来是指向了方法（function），其实指向的是方法 return 的结果。computed 计算属性的特性是计算结果会被缓存，如果 function 中依赖的响应式属性发生变化，computed 便会重新计算。注意如果依赖实例之外的属性（比如非响应式属性）则计算结果不会更新。此外，如果在计算属性中使用了箭头函数，则 this 不会指向组件的实例，但在函数中依然可以将实例以函数的第一个参数访问。如下： 123computed: &#123; aDouble: vm =&gt; vm.a * 2&#125;","text":"为什么写这篇笔记？记得在以往的面试中多次被问到这个问题，回答的都不理想，仔细想想也是理解的不到位。今天借着休息的时间准备查阅文档，写写示例代码去仔细理解下。 computed 计算属性是什么？computed 计算属性介绍：computed 计算属性是一个对象。它的使用方法是在 computed 属性中定义一个方法，和给对象定义方法一样，方法名可以直接在页面（template）中使用，不需要加 （），这是因为计算属性看起来是指向了方法（function），其实指向的是方法 return 的结果。computed 计算属性的特性是计算结果会被缓存，如果 function 中依赖的响应式属性发生变化，computed 便会重新计算。注意如果依赖实例之外的属性（比如非响应式属性）则计算结果不会更新。此外，如果在计算属性中使用了箭头函数，则 this 不会指向组件的实例，但在函数中依然可以将实例以函数的第一个参数访问。如下： 123computed: &#123; aDouble: vm =&gt; vm.a * 2&#125; 此外，计算属性默认只有 getter ，但也可以使用 setter 。具体操作示例请看 计算属性的 getter 和 setter 计算属性使用示例： 12345computed: &#123; newList: function() &#123; return this.brandList.filter(item =&gt; item.name.indexOf(this.keywords) !== -1); &#125; &#125; 什么时候使用计算属性？模板内表达式多用于简单计算，这样便于阅读代码时的理解。如果在模板表达式里使用复杂的运算，一是难以理解，二是不能复用。你可能会说，那我在 methods 中定义一个方法， return 处理结果也可以啊。是的，可以。但不同之处在于，计算属性会缓存计算结果，只在依赖的响应式属性发生变化时，才会更新数据。这是计算属性的性能优势。更多详情可访问 Vue 之 computed 属性 watch 侦听器是什么？watch 侦听器介绍watch 属性是一个对象，键（key)可以是 Vue 实例的表达式（字面量）和字符串（data 中定义的数据），值是回调函数，也可以是方法名、包含了方法的对象和方法集合的数组。回调函数的参数包含了新值和旧值。同时，如果需要对对象的值做进一步侦听，需要将键（key）对应的值设为对象，在对象的身上定义回调函数，再设置 deep 属性为 true。同时如果设置 immediate: true，则回调会在侦听开始之前调用。需要注意的是 watcher 函数不能是箭头函数，官网的解释是箭头函数绑定了父级作用域上下文，会使 this 不能按照期望指向 Vue 实例。 什么时候使用侦听器？当需要在数据变化时做异步或者开销比较大的操作时，watch 比较有用。 详细介绍可以访问 Vue 官网查看 watch 属性介绍。 Vue 之 watch 属性 总结：computed 计算属性和 watch 侦听器的区别相同点都是在数据发生变化需要进行处理的时候使用。 不同点 使用方式上计算属性是依据响应式属性得出的计算属性，使用时需要调用，且不加（），会缓存数据，在响应式属性更新时，计算属性也更新。侦听器不需要调用，会在侦听属性发生变化时，自动调用。注意，计算属性必须 return 一个结果，也就是处理后的计算属性的值。而侦听器则不需要。 使用场景上计算属性多用于依据一个或多个响应式属性得到另一个计算属性。比如：姓+名=全名。比如购物车结算金额时。侦听器多用于复杂场景或需要异步操作时，比如搜索时实时出现搜索建议或提示。搜索场景代码示例可访问Vue 之 侦听器。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"flex 布局之 \"flex: 1;\"","slug":"flex 布局之 flex 1","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-05T09:42:13.617Z","comments":true,"path":"2020/04/03/flex 布局之 flex 1/","link":"","permalink":"http://yoursite.com/2020/04/03/flex 布局之 flex 1/","excerpt":"flex: 1; 到底是什么意思？首先 flex 是 flex-grow, flex-shrink, flex-basis. 三个属性的简写，默认值为 0 1 auto。该属性有两个快捷值：auto(1 1 auto) 和 none(0 0 auto)。建议优先写 flex 属性，而不是写三个分离的属性，因为浏览器会自动计算其相关值。 flex-grow 默认为 0， 只能是正整数。即父元素有剩余空间也不放大元素。如果为 1，则把剩余空间的一份加给自己的宽度。 flex-shrink 默认为 1，只能是正整数。即父元素空间不足则按比例收缩。如果为 0，则不收缩 flex-basis 默认为 auto, 即元素本身的大小。这个属性定义了在分配多余空间之前，元素占据的主轴空间，浏览器根据这个属性计算是否有多余空间。可以设置为和 width 和 height 属性一样的值，比如 220px，则元素占据固定空间。 以上大部分是我初次学习 flex 布局记下的笔记内容。","text":"flex: 1; 到底是什么意思？首先 flex 是 flex-grow, flex-shrink, flex-basis. 三个属性的简写，默认值为 0 1 auto。该属性有两个快捷值：auto(1 1 auto) 和 none(0 0 auto)。建议优先写 flex 属性，而不是写三个分离的属性，因为浏览器会自动计算其相关值。 flex-grow 默认为 0， 只能是正整数。即父元素有剩余空间也不放大元素。如果为 1，则把剩余空间的一份加给自己的宽度。 flex-shrink 默认为 1，只能是正整数。即父元素空间不足则按比例收缩。如果为 0，则不收缩 flex-basis 默认为 auto, 即元素本身的大小。这个属性定义了在分配多余空间之前，元素占据的主轴空间，浏览器根据这个属性计算是否有多余空间。可以设置为和 width 和 height 属性一样的值，比如 220px，则元素占据固定空间。 以上大部分是我初次学习 flex 布局记下的笔记内容。 查阅笔记得知，flex 取值有两种情况。一是非负数字，二是长度或者百分比。当 flex 取非负数字时。比如 1 ，则该数字为 flex-grow 的值，flex-shrink 为 1 ，flex-basis 为 0%，则如下是等同的: 12345678.item &#123; flex: 1;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; _注_：当 flex-basis 取值为百分比时根据伸缩父容器的主尺寸计算，如果伸缩父容器的主尺寸没有定义（即父容器宽度取决于子元素）则计算结果和 auto 一样。 最终结果根据以上分析：flex: 1; 的值是 flex-grow: 1; flex-shrink: 1; flex-basis: 0%; 意思就是：元素占据剩余宽度的 1 份，收缩比例为 1，因为 flex-basis 具有最高优先级，元素首次分配宽度（flex-direction: colunm; 则为高度）如果父元素有设置宽度，则为 0%；父元素没有设置宽度，则和 auto 效果一致。 关于 flex 布局推荐下面一篇文章看，写的很好，今天写这篇博客搜到读之受益匪浅。 Flexbox，终于可以承认自己明白了","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://yoursite.com/tags/flex/"}]},{"title":"记一次bug：微信小程序真机调试访问接口失败","slug":"记一次bug：微信小程序真机调试访问接口失败","date":"2020-04-02T07:53:00.000Z","updated":"2020-04-05T09:37:48.065Z","comments":true,"path":"2020/04/02/记一次bug：微信小程序真机调试访问接口失败/","link":"","permalink":"http://yoursite.com/2020/04/02/记一次bug：微信小程序真机调试访问接口失败/","excerpt":"一、开发情况简述：后端未部署，目前开发阶段直接连同事电脑，前端由我负责。 二、问题描述最近在使用 uni-app 开发微信小程序时，遇到了真机调试接口访问失败的问题。一开始草草的翻了官方文档，没看出个所以然。昨天在网上搜了一下原因，记得有网友提到了防火墙的问题。今天上午我试着关闭本机的防火墙后，还是不行。","text":"一、开发情况简述：后端未部署，目前开发阶段直接连同事电脑，前端由我负责。 二、问题描述最近在使用 uni-app 开发微信小程序时，遇到了真机调试接口访问失败的问题。一开始草草的翻了官方文档，没看出个所以然。昨天在网上搜了一下原因，记得有网友提到了防火墙的问题。今天上午我试着关闭本机的防火墙后，还是不行。 猛然间想到应该是要手机、电脑处于同一个网络下，我不记得昨天查的资料是否说了同一个网络的问题了，但想到去年秋天自己折腾 uni-app 开发安卓应用时，真机调试好像有要求手机和电脑处于同一个网络下。以前使用 appCan 开发应用时记得也是。然后使用 win10 系统自带的移动热点开启了一个无线网络给手机连接。 再次打开微信开发者工具的真机调试后，手机上运行小程序真的可以正常访问接口了。 but…测试一当我开启防火墙后，真机调试接口依然可以正常访问（访问正常的图就不贴了）。 测试二当我再次让手机和电脑处于同一个无线网下时，结果报错了。 三、结语根据实际测试得出如下结果： 需要关闭防火墙是真的，但是是由提供服务的后端同事关闭其电脑防火墙，之前遇到过这个问题，就是后端关闭防火墙解决的。前端其实无所谓。 处于同一个网络也是真的，但是是前端电脑和后端电脑及真机调试手机处于同一个网络下，这样服务可以正常访问，微信开发者工具的真机调试也才正常。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"http://yoursite.com/tags/BUG/"}]},{"title":"记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件","slug":"记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件","date":"2020-04-01T05:45:23.000Z","updated":"2020-04-05T09:38:04.316Z","comments":true,"path":"2020/04/01/记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件/","link":"","permalink":"http://yoursite.com/2020/04/01/记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件/","excerpt":"前言layuiAdmin pro 使用 gulp 构建源码时, controller 里的大部分文件夹里的 js 代码没有压缩输出，但也未报错。 问题详述 src/controller 目录结构如图：","text":"前言layuiAdmin pro 使用 gulp 构建源码时, controller 里的大部分文件夹里的 js 代码没有压缩输出，但也未报错。 问题详述 src/controller 目录结构如图： 执行 gulp 构建源码命令后的 dist/controller 目录结构如图，明显少了一些文件夹。 gulpfile.js 中调用 gulp-uglify 压缩 js 的代码如图： cmd 命令行中 gulp 命令执行结果截图： 原因排查排查过程 依据 layuiAdmin pro 文档，确认了 node 及 npm 没有问题，gulp 已全局安装，其依赖也已安装。 确认 layuiAdmin pro 中的 gulpfile.js 代码除了引入 babel 增加处理 ES6 的代码外，没有改变。 确认语法及 API 问题，经查阅资料:3.1 gulp.src() 中的路径 &#39;./src/**/*.js&#39; 没有错误，就是查找 src 下任意文件夹里的 js 文件。3.2 gulp.dest() 中文件输出路径没问题。3.3 uglify() 调用没有问题。3.4 gulp 引入等没有问题。 尝试升级 gulp-uglify 至最新版 3.0.2 没有作用。 依据 layuiAdmin pro 文档,确认是否由框架的缓存机制引起？虽然很可能应该无关，囧… 结论是没有用，无关缓存机制的事情。 尝试压缩某个具体文件 &#39;./src/controller/businessBasic/blackAndWhite/blackAndWhite.js&#39;， 也是无效。但是事情终于有了转机。 终于找到问题所在 点开这个未被压缩输出的文件发现是有语法错误，而问题仅仅是在 js 文件中使用了 html 的注释语法，继而导致文件没有被 gulp-uglify 正常压缩和输出。错误如图： 修正注释语法的错误后，终于可以正常压缩输出 js 文件了。 错误原因分析项目前端代码由后端同事兼职编写，后端同事对于前端技术不够熟悉，以至于使用了错误的注释语法，最终导致 js 文件没有被正确压缩输出。并且后端同事多使用 webstorm IDE，而 webstorm 没有提示注释语法错误。相反 vs code 有提示注释语法错误。 结语有时候低级的错误反而难以查找，就像功夫再高也怕菜刀和乱拳打死老师傅。相信专业的人做专业的事情，避免低级错误。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"http://yoursite.com/tags/BUG/"}]},{"title":"Vue 和 React 的异同","slug":"Vue 和 React 的异同","date":"2018-11-22T01:55:00.000Z","updated":"2020-04-06T06:37:11.023Z","comments":true,"path":"2018/11/22/Vue 和 React 的异同/","link":"","permalink":"http://yoursite.com/2018/11/22/Vue 和 React 的异同/","excerpt":"","text":"相同点 都有虚拟 DOM，都有组件概念，都有自己的构建工具，都有自己的 Chrome 调试工具，都支持服务端渲染，都是数据驱动视图。 都通过 props 参数进行父子组件的数据传递。 不同点 Vue 使用普通的 HTML 书写页面结构。而 React 使用 JSX 书写页面结构，也就是在 JS 中书写 HTML 。（从技术上来说，Vue 也支持 render 函数和 JSX 语法。） Vue 文档友好，相对简单易学，便于整合现有系统，不需要整体重构。而 React 文档是英文的，组件更多靠 JS 实现。 Vue 由尤雨溪的团队维护，React 由 Facebook 官方维护。vue-router 和 vuex 由 Vue 官方维护，而 react-router 和 react-redux 由社区成员维护。 Vue 使用 data 属性保存数据，而 React 使用 state 对象保存数据，state 对象要使用 setState() 方法改变状态。 Vue 构建移动应用的 weex 仍处于开发试验阶段，不够完善，而 React Native 更加成熟强大。 Vue 会追踪每个组件的状态，不会重新渲染整个组件树，而 React 会重新渲染所有的子组件，所以 React 有 shouldComponentUpdated 生命周期函数去控制。 Vue 使用单文件创建组件，而 React 使用 JSX + 行内样式创建组件。 Vue 支持双向数据绑定，而 React 是单向数据流，需要自己去模拟实现。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"Vue React","slug":"Vue-React","permalink":"http://yoursite.com/tags/Vue-React/"}]},{"title":"ECMAScript 关键字整理（部分）","slug":"ECMAScript 关键字整理","date":"2018-04-23T12:31:00.000Z","updated":"2020-04-05T08:48:55.370Z","comments":true,"path":"2018/04/23/ECMAScript 关键字整理/","link":"","permalink":"http://yoursite.com/2018/04/23/ECMAScript 关键字整理/","excerpt":"ECMAScript 关键字 function解释：function 关键字用于创建一个函数。语法： 123function()&#123;&#125; this解释：this 关键字在 js 中是指当前行为执行的主体。 this 指向 普通函数调用，this 指向 window 。注意：严格模式（’use strict’）下，this 指向 undefined 。 构造函数中 this 指向构造函数实例化出来的对象，原型方法中的 this 也是指向实例化对象。 方法调用中 this 指向调用该方法的对象。 事件处理函数中的 this 指向触发事件的对象（事件源）。 定时器中的 this 指向 window 。 new解释：new 关键字用于搭配构造函数创建实例化对象。 new 关键字执行过程 创建空对象。 让 this 指向空对象。 执行构造函数，给创建的新对象添加属性和方法。 返回对象给函数的调用者。 return解释：return 关键字用于函数中，使用 return 可以返回需要返回的值，return 后面可以是任意的 js 数据类型。return 后面不写数据会返回 undefined 。return 后面的代码不再执行，直接结束函数。return 关键字作用范围是函数内。语法： 123function()&#123; return;&#125;","text":"ECMAScript 关键字 function解释：function 关键字用于创建一个函数。语法： 123function()&#123;&#125; this解释：this 关键字在 js 中是指当前行为执行的主体。 this 指向 普通函数调用，this 指向 window 。注意：严格模式（’use strict’）下，this 指向 undefined 。 构造函数中 this 指向构造函数实例化出来的对象，原型方法中的 this 也是指向实例化对象。 方法调用中 this 指向调用该方法的对象。 事件处理函数中的 this 指向触发事件的对象（事件源）。 定时器中的 this 指向 window 。 new解释：new 关键字用于搭配构造函数创建实例化对象。 new 关键字执行过程 创建空对象。 让 this 指向空对象。 执行构造函数，给创建的新对象添加属性和方法。 返回对象给函数的调用者。 return解释：return 关键字用于函数中，使用 return 可以返回需要返回的值，return 后面可以是任意的 js 数据类型。return 后面不写数据会返回 undefined 。return 后面的代码不再执行，直接结束函数。return 关键字作用范围是函数内。语法： 123function()&#123; return;&#125; for解释：for 关键字用于创建一个 for 循环。语法： 123for()&#123;&#125; if解释：if 关键字和 else 一起用于创建一个 if else 分支语句。语法： 12345if()&#123;&#125;else&#123;&#125; else解释：一般搭配 if 使用 while解释：while 关键字用于创建一个 while 循环。语法： 123while()&#123;&#125; do解释：do 关键字 和 while 一起用于创建一个 do while 循环。语法： 123do&#123; &#125;while() switch解释：switch 关键字用于创建一个 switch 分支语句。语法： 123456switch (key) &#123; case value: break; default: break;&#125; case解释：一般搭配 switch 使用 default解释：一般搭配 switch 使用 break解释：break 关键字在循环中是结束整个循环，继续执行循环后的代码。在 switch 中是阻止代码向下执行，跳出 switch 语句。break 关键字的作用范围是循环和 switch 语句内。语法： 123for() &#123; break;&#125; continue解释：continue 关键字用于结束当前的这一次循环，continue 之后的代码不再执行，继续下一次循环。其作用范围循环内。语法： 123for()&#123; continue;&#125; var解释：var 关键字用于声明一个变量。语法： 1var str = &apos;hello world&apos;; typeof解释：typeof 关键字用于获取变量的类型。会返回具体的数据类型，这个返回值是字符串类型的。注意：typeof 只能区分出基本数据类型和函数，不能区分出对象和数组。语法： 1typeof 变量 instanceof解释：instanceof 关键字用于判断 Object.prototype 是否出现在某个对象的原型链上。简单来说就是用于检测某一个实例对象是否属于某一个构造函数，返回布尔值。 in解释：in 关键字用于判断一个属性是否在一个对象中。有就返回 true ，没有返回 false 。语法： 1in 的是左边字符串，右边是对象 delete解释：delete 关键字用来删除一个非 var 声明的全局变量。或者删除对象里面的某一个属性。或者删除数组里的某一项。删除成功返回 true ， 失败返回 false 。 void解释：void 关键字用来表示不访问数据，可以阻止 a 标签的默认跳转行为。用在 a 标签中 ，href=“javascript:void(0)”。语法： 1&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; throw解释：throw 关键字用于抛出异常。 catch解释：catch 关键字用于捕获异常。常与 try、finally 配合使用。 try解释：一般搭配 catch 使用 finally解释：一般搭配 catch 使用 with解释：更新当前作用域。 参考资料W3scool 之 ECMAScript 关键字","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"JavaScript ECMAScript","slug":"JavaScript-ECMAScript","permalink":"http://yoursite.com/tags/JavaScript-ECMAScript/"}]},{"title":"我的设计作品","slug":"我的设计作品","date":"2017-04-25T12:08:32.000Z","updated":"2020-04-06T06:26:31.217Z","comments":true,"path":"2017/04/25/我的设计作品/","link":"","permalink":"http://yoursite.com/2017/04/25/我的设计作品/","excerpt":"","text":"本人喜欢前端开发，大学专业是软件工程（数字多媒体方向），对设计方面略懂一点，也比较热爱骑行。上图是我以前为我们学校的骑行车队——周师如风车队（非官方组织）设计的队旗，Logo 部分有借鉴一位网友的设计。","categories":[{"name":"设计","slug":"design","permalink":"http://yoursite.com/categories/design/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"Web 前端的发展现状及未来机遇","slug":"Web 前端的发展现状及未来机遇","date":"2017-04-23T10:43:17.000Z","updated":"2020-04-06T06:28:48.815Z","comments":true,"path":"2017/04/23/Web 前端的发展现状及未来机遇/","link":"","permalink":"http://yoursite.com/2017/04/23/Web 前端的发展现状及未来机遇/","excerpt":"Web 前端的历史Web 前端的由来&emsp;&emsp;1991 年 8 月，Tim Berners-Lee 发布了第一个简单的，基于文本，包含几个链接的网站。但此后的网站发展一直很缓慢，这是因为早期的网页完全由单调的文本和图片所构成，对人们而言，毫无吸引力。到了 2005 年，互联网开始进入 Web2.0 时代，各种类似桌面软件的 Web 应用开始大量涌现，由此，网站建设发生了巨大的变革。与此同时，“前端”这个词开始在国内逐渐流行开来。 什么是前端&emsp;&emsp;我们一直说前端，但什么是前端呢？前端可以笼统的解释为凡是通过浏览器把内容呈现给用户的统称为前端。相反贮存于服务器端的则统称为后端。&emsp;&emsp;前端这个词是从网页制作演变过来的，名称上有着明显的时代特征。在互联网的演化过程中，网页制作是 Web1.0 时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。在这个阶段，网站的内容主要是文字和图片为主，制作方法也主要是使用 table 和 ASP。后来发展到使用 HTML、CSS、JavaScript 等前端技术构建页面。到现在，前端技术已经发展到 HTML5、CSS3、EcmaScript6 等，以后也会继续发展、继续完善。&emsp;&emsp;Web 前端虽然起步时间晚，但是发展势头迅猛，在各种新技术、新标准的推动下，各大互联网公司也开始重视 Web 产品的前端重构与开发，如淘宝、腾讯、新浪、百度、搜狐等都对自己的网站进行了重构并同时使用了 HTML5 中的新特性。现在开发的 Web 新产品的页面交互也越来越丰富，视觉效果也越来越绚丽。互联网公司除了重视前端开发之外，还在积极推动互联网技术的发展，2001 ～ 2012 年，腾讯、百度及奇虎 360 公司先后加入了万维网联盟（W3C），共同参与互联网技术标准的研究和制定，促进了国内互联网产业的发展。","text":"Web 前端的历史Web 前端的由来&emsp;&emsp;1991 年 8 月，Tim Berners-Lee 发布了第一个简单的，基于文本，包含几个链接的网站。但此后的网站发展一直很缓慢，这是因为早期的网页完全由单调的文本和图片所构成，对人们而言，毫无吸引力。到了 2005 年，互联网开始进入 Web2.0 时代，各种类似桌面软件的 Web 应用开始大量涌现，由此，网站建设发生了巨大的变革。与此同时，“前端”这个词开始在国内逐渐流行开来。 什么是前端&emsp;&emsp;我们一直说前端，但什么是前端呢？前端可以笼统的解释为凡是通过浏览器把内容呈现给用户的统称为前端。相反贮存于服务器端的则统称为后端。&emsp;&emsp;前端这个词是从网页制作演变过来的，名称上有着明显的时代特征。在互联网的演化过程中，网页制作是 Web1.0 时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。在这个阶段，网站的内容主要是文字和图片为主，制作方法也主要是使用 table 和 ASP。后来发展到使用 HTML、CSS、JavaScript 等前端技术构建页面。到现在，前端技术已经发展到 HTML5、CSS3、EcmaScript6 等，以后也会继续发展、继续完善。&emsp;&emsp;Web 前端虽然起步时间晚，但是发展势头迅猛，在各种新技术、新标准的推动下，各大互联网公司也开始重视 Web 产品的前端重构与开发，如淘宝、腾讯、新浪、百度、搜狐等都对自己的网站进行了重构并同时使用了 HTML5 中的新特性。现在开发的 Web 新产品的页面交互也越来越丰富，视觉效果也越来越绚丽。互联网公司除了重视前端开发之外，还在积极推动互联网技术的发展，2001 ～ 2012 年，腾讯、百度及奇虎 360 公司先后加入了万维网联盟（W3C），共同参与互联网技术标准的研究和制定，促进了国内互联网产业的发展。 Web 前端的技术与责任Web 前端技术&emsp;&emsp;Web 前端技术包括三个要素：HTML、CSS 和 JavaScript。 HTML（HyperText Markup Language）指超文本标记语言，是目前 Web 领域应用最广泛的标记语言，用来书写网页结构。CSS（Cascading Style Sheets）指层叠样式表，可以用来美化网页，也称为网页的表现层。而 JavaScript 则是网页的行为层，它可以用来书写页面交互效果。构建网页的一个最重要原则就是“结构、样式、行为”三层分离。 Web 前端的责任&emsp;&emsp;Web 前端工程师的主要职责是利用 HTML、CSS 书写符合 Web 标准的语义化代码来搭建网页，通过 JavaScript 来实现网页交互功能，致力于通过技术改善用户体验。Web 前端，往后是技术，往前是体验。Web 前端工程师既要与项目下游的服务器端工程师沟通，又要与项目上游的交互设计师、UI 设计师和产品经理沟通，需要掌握的技能非常多。这就从知识的广度上对 Web 前端开发工程师提出了要求。&emsp;&emsp;随着人们生活水平的提高，用户体验变得比以往更重要，而 Web 前端是后端数据的第一消费者，也是最贴近用户的程序员，因此提升用户体验是 Web 前端工程师的重要责任。 Web 前端的发展现状行业的发展现状&emsp;&emsp;第一，供求关系的不平衡。2015 年创业公司如雨后春笋一般冒了出来，而 2016 年下半年开始，更多的创业公司开始倒闭。与各个创业公司拔地而起同时发生的，还有大批其他行业工作者涌入 Web 前端这个当前比较火爆的行业。“公司数量的变化”与“大量从业者的涌入”这两点直接影响着供求关系。在当前以及未来的一段时间之内，会呈现典型的“供大于求”的行业状态；&emsp;&emsp;第二，前端行业日益成熟。在最初前端行业刚刚起步之时，各类的内容、功能都不够完善，需要大量的人去做“重复的事”，也需要不少人去研究和探索新的事物和技术。随着前端行业逐渐走向成熟，前端当中的主流框架层出不穷，除了最为经典的 jQuery 之外，还有 VUE、React、Angular 等等。当下，“前端”已经开始步入模块化、工程化，曾经大量繁琐而复杂的工作逐渐被模板或工具所替代。&emsp;&emsp;当一个行业日益成熟，势必会降低行业中的重复性工作，一个工作者在同一时间内完成的工作量也会大大增加，那么所需要的工作者数量自然会有所下降。整个 Web 前端行业之后将会进入一种趋于稳定发展的状态。 Web 前端开发体会&emsp;&emsp;Web 前端开发是一个较新的职业，它是在 Web2.0 的热潮下成长起来的，要求开发者掌握较综合的技能，除了必要的软件开发技术，还要对可用性有一定的了解，而又对设计有一定要求，因此，对于数字多媒体技术专业的学生来说，有着天然的优势，是最适合不过的职业之一。&emsp;&emsp;但是对于数字多媒体技术专业的学生，如果要在未来的就业中掌握主动权，单靠专业优势是远远不够的，还需要有深厚的技术功力，例如 HTML + CSS 技术，是必须要完全掌握精通的，JavaScript 更是要不断深耕细作，在专业达到一定的深度后，才有能力在工作中游刃有余，所向披靡。&emsp;&emsp;同时，在学习研究的过程中，要不断增加自己的项目经验，为自己增加筹码，由于前端开发行业的特殊性，数字媒体技术的学生在大三就可以开始在社会中寻找工作经验了，一些学校项目，工作室项目，社会兼职实习等，都是这些经验的重要来源。Web 前端开发是需要在不断实践中学习的，拥有一定的项目经验，才能在学习中得以扩展深入，否则很多单纯意义上的学习更像纸上谈兵，没有意义。 浏览器发展对 Web 前端的重要影响&emsp;&emsp;在 Web 前端发展的过程中，浏览器的发展起着至关重要的作用。浏览器厂商在这场 Web 浪潮中表现突出，具体表现在浏览器的版本升级周期短、对前端标准的支持也越来越好、浏览器的性能也有大幅的提升等。IE 浏览器也开始发力，最新发布的 IE 11 浏览器无论是标准的支持还是性能都比以往表现更好。浏览器的快速发展使得低端的浏览器如 IE 6、IE 7 等慢慢退出市场。&emsp;&emsp;2006 年，John Resig 开发的基于 JavaScript 的 jQuery 框架发布，其最大的突破在于让老旧浏览器适配新的 Web 标准，jQuery 框架从某种意义上解决了 PC 端浏览器兼容性的问题。&emsp;&emsp;目前，移动设备的普及率极高，用户已经逐渐习惯于通过移动设备来浏览网页。主流的移动平台主要为 Android 和 iOS 系统，对应的浏览器内核都是 WebKit，性能和对标准的支持都不错，这恰好也是移动 Web 应用的发展机遇。 Web 前端面临的挑战&emsp;&emsp;Web 前端技术也面临一些挑战。如今大量旧的网站需要重构来提高网站用户体验和性能，这些网站的前端代码普遍存在的问题有：代码没有实现三层分离，代码不够简洁高效，页面布局随意，网站整体性能差，不利于后期维护。 Web 前端的未来机遇Web 前端的发展方向&emsp;&emsp;新标准的进化与稳定。目前前端三层结构已经形成了 HTML5、CSS3、EcmaScript6 标准规范结合的阶段，后面标准的新变化也会越来越小，至少迄今为止，我们无法预见 HTML6 的到来、CSS4 的特性目前也令人担忧、EcmaScript7 的特性更新也并不明显，这都显示出，目前前端项目实践规范将会相对稳定一段较长的时间，后面的修改不会像之前一样具有颠覆性，这也是技术标准发展到一定成熟阶段会发生的事情。&emsp;&emsp;持续不断的技术工具探索。前端技术效率和性能的提升当然不是仅靠前端框架就能解决的，还需要其他各方面辅助工具的支持，比如高效的调试工具、构建自动化工具等。所以未来前端发展过程中各种高效工具的探索仍会不断地出现，来解决特定场景下的问题，最后进行优胜劣汰。&emsp;&emsp;前端新领域的出现。除了目前浏览器、服务器、移动端上的应用开发技术变革和探索外，未来前端也会出现新的应用场景。比如 VR、物联网 Web 化、Web 人工智能等。这些虽然听着比较远，但一旦到来就会很快被使用，所以前端不仅自身发展快，推广使用也极其迅速，例如移动互联网 Web 的普及也就两三年时间。 近几年，Web VR 和物联网 Web 化的概念渐渐出现，国外甚至出现了以人工智能为支撑的 Web 应用。 前端的繁荣值得期待&emsp;&emsp;Web 前端技术的发展日新月异，现在业内已经开始提出 Web3.0 的概念。最常见的解释是，网站内的信息可以直接和其他网站相关信息进行交互，能通过第三方信息平台同时对多家网站的信息进行整合使用；用户在互联网上拥有自己的数据，并能在不同网站上使用；完全基于 Web，用浏览器即可实现复杂系统程序才能实现的系统功能；用户数据审计之后，同步于网络数据。&emsp;&emsp;现在的 Web 前端开发越来越注重用户体验。无论底层技术的支持上，还是跨平台兼容的需求上，都为迎来前端的繁荣局面做好了准备。预计前端主导的产品会越来越多，前端工程师的位置会越来越重要。最后引用乔布斯的话，“Web 就是未来”。我们作为前端开发工作者也是未来。相信 Web 前端的明天会更好。 附录：参考书籍和文章《Web 前端开发最佳实践》 –党建 2015 年 1 月 《聊聊未来的前端时代》 –ouven 2016 年 12 月 11 日 《HTML5 行业现状与未来 - 2016 年终大盘点》 2017-01-20 19:03","categories":[{"name":"文章","slug":"文章","permalink":"http://yoursite.com/categories/文章/"}],"tags":[{"name":"前端","slug":"frontEnd","permalink":"http://yoursite.com/tags/frontEnd/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-09T16:00:00.000Z","updated":"2020-04-05T08:47:11.859Z","comments":true,"path":"2017/04/10/hello-world/","link":"","permalink":"http://yoursite.com/2017/04/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}