{"meta":{"title":"皇甫文豪'S BLOG","subtitle":"江上之清风，山间之明月","description":"书犹药也，善读之可以医愚。— — (汉)刘向","author":"YACHU","url":"http://yoursite.com"},"pages":[{"title":"About me","date":"2017-04-27T13:29:25.000Z","updated":"2020-04-05T09:09:12.360Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"作者简介：个人信息姓名：皇甫文豪，男，90 后。籍贯：河南省。职业：WEB 前端工程师。2013 年 9 月至 2017 年 6 月就读于周口师范学院全日制本科软件工程专业。 三年前端开发经验，掌握前端基本功，熟悉常用的前端技术及工具，擅长 Vue。 主修课程：数据结构、计算机网络，操作系统，计算机组成原理，网页设计与开发，C# 高级程序设计，SQL Server 数据库等。 技术特长： 熟练掌握 HTML、CSS 网页布局技术。 掌握 CSS 预处理语言 Less 。 对移动端布局有一定了解，熟悉 Rem 布局，Flex 布局，流式布局，响应式布局等。 熟悉前端 UI 框架 Bootstrap、MUI。 掌握 JavaScript 的原型链，继承，闭包，递归等。 熟悉 jQuery，Lodash，Zepto 等常用 JavaScript 库。 掌握原生 Ajax 请求，熟悉 HTTP 协议。能使用 Art-Template 模板快速渲染数据。 了解浏览器同源策略，能使用 JSONP，Nginx 等解决跨域问题。 理解面向对象思想，对前端的模块化和组件化有一定了解。 熟悉 HTML5，CSS3 新特性及 ECMAScript 6 常用语法。 掌握 Vue 全家桶及其组件库 Element-UI 的使用。熟悉 Axios 的使用。 熟悉 React 的基本使用，熟悉 Styled components 样式组件和 Next.js 服务端渲染。 熟练使用 Webpack 进行项目的构建与打包，了解 gulp 。 熟练使用 Git 版本控制工具进行代码管理。熟悉 NPM 包管理器。 熟悉微信公众号和微信小程序开发。 熟悉 uni-app 跨端开发框架，可跨端开发小程序和 hybrid app 等。 熟悉前端 Excel 框架 SpreadJS。熟悉 appCan 开发 Hybrid app。 熟悉 Layui 框架，熟悉 CoreUI，使用过 CureUI/Vue 开发过项目。 了解 Node.js 及其框架 Express。 寄语自己：我对 Web 前端开发有着浓厚的兴趣，我相信科技改变生活，希望通过前端技术为改善互联网的用户体验出一份力。我也希望能在技术分享这一块做出自己的一些贡献，希望通过博客来分享自己的学习经验，分享项目开发中所遇到问题以及解决方案，所以建立了自己的个人博客网站，希冀为前端行业的进步与发展贡献自己的一点绵薄之力。同时我热爱骑行，喜欢团队协作去挑战困难的热烈氛围。曾于 2015 年 7 月从河南周口出发，历时近一个月骑行进入西藏。后又在 2019 年 8 月再次由大理自滇藏线骑行至拉萨。 联系方式：个人邮箱：huangfuwh@163.com"},{"title":"分类","date":"2018-04-18T12:32:09.000Z","updated":"2018-04-18T12:36:41.050Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-18T12:33:52.000Z","updated":"2018-04-18T12:36:35.060Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一次 bug : 表单提交时携带不上文件数据","slug":"20. 记一次 bug ： 表单提交时携带不上文件数据","date":"2020-04-17T16:00:00.000Z","updated":"2020-04-17T17:00:48.274Z","comments":true,"path":"2020/04/18/20. 记一次 bug ： 表单提交时携带不上文件数据/","link":"","permalink":"http://yoursite.com/2020/04/18/20. 记一次 bug ： 表单提交时携带不上文件数据/","excerpt":"前言这段时间我负责的基于 coreui/vue 的后台管理项目遇到难题了。在开发商品上架功能时，表单提交时，上传的图片数据始终为空，参数携带不了。但在发送请求之前是可以正常打印文件数据的。 尝试解决 设置 content-type12345678let config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data&quot; &#125;&#125;;this.$http .post(&quot;/product/add&quot;, params, config) .then().catch() 结果是不 OK。","text":"前言这段时间我负责的基于 coreui/vue 的后台管理项目遇到难题了。在开发商品上架功能时，表单提交时，上传的图片数据始终为空，参数携带不了。但在发送请求之前是可以正常打印文件数据的。 尝试解决 设置 content-type12345678let config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data&quot; &#125;&#125;;this.$http .post(&quot;/product/add&quot;, params, config) .then().catch() 结果是不 OK。 尝试组件的其他 API 进行 files 字段赋值，确认是不是 v-model 无效？123456789101112131415161718192021&lt;b-form-group label=&quot;商品缩略图&quot; label-for=&quot;fileInput&quot; :label-cols=&quot;3&quot;&gt;&lt;!-- plain: 采用默认的原始样式，multiple: 多选 --&gt;&lt;b-form-file id=&quot;fileInput&quot; v-model=&quot;goodsData.files&quot; placeholder=&quot;选择一张图片&quot; drop-placeholder=&quot;拖拽图片到这里&quot; accept=&quot;image/*&quot; browseText=&quot;浏览&quot; @change=&quot;uploadPicture&quot; @input=&quot;selectPicture&quot;&gt;&lt;/b-form-file&gt;&lt;/b-form-group&gt;// methods ，赋值过程不再复现uploadPicture(e) &#123; console.log(e.target.files);&#125;,selectPicture(val) &#123; console.log(val);&#125; 结果依旧不行。 尝试操作 b-form-file 的 name 属性依旧不行。转机近几日管理系统项目赶进度要上测试环境，对应的小程序要上体验版。就再次网上查了查文件上传，运行了网上一个文件上传案例时，发现需要 new FormData 实例，将 files 文件数据 append 进实例就可以了。解决实例代码：123456789101112131415161718192021222324252627282930 onSubmit() &#123; if (Object.values(this.goodsData).indexOf(&quot;&quot;) !== -1) &#123; this.showErrorMsg(&#123; message: &quot;有必填项为空&quot; &#125;); return; &#125; if (this.goodsData.files.length === 0) &#123; this.showErrorMsg(&#123; message: &quot;请至少上传一张图片&quot; &#125;); return; &#125; // 表单提交，数据处理 let params = new FormData(); // params.append(&apos;files&apos;, this.goodsData.files) for (let key in this.goodsData) &#123; params.append(key, this.goodsData[key]); &#125; let config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data&quot; &#125; &#125;; this.$http .post(&quot;/product/add&quot;, params, config) // .post(&quot;/product/add&quot;, this.goodsData) .then(res =&gt; &#123; // 略 &#125;) .catch(error =&gt; &#123; // 略 &#125;);&#125;, 问题被完美解决。 总结vue + axios 实现文件上传在拿到文件数据后还需要满足一下条件 默认的 content-type 为 json, 需要设置为 formdata格式的。 new FormData 实例，将需要传递的参数 append 进 实例中。参考文章vue+axios上传文件","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue 中 echarts 等图表如何实现响应式更新？","slug":"19. vue 中 echarts 等图表如何实现响应式更新？","date":"2020-04-16T18:00:00.000Z","updated":"2020-04-17T16:58:41.179Z","comments":true,"path":"2020/04/17/19. vue 中 echarts 等图表如何实现响应式更新？/","link":"","permalink":"http://yoursite.com/2020/04/17/19. vue 中 echarts 等图表如何实现响应式更新？/","excerpt":"前言最近的项目使用了 vue-chartjs 图表和 echarts 图表。昨天联调接口发现接口返回数据后，图表没有根据数据更新。还是默认数据渲染的图表。 排查确认了接口没问题和代码也没报错后。审查代码发现是图表的渲染是在 mounted 中执行的，而这个生命周期函数只执行一次，所以数据更新了，图表没有响应式更新也是正常的。本来还以为是要调用专门的 API 去刷新图表。 解决经过网上查找资料发现，其实只要使用 watch 检测数据，然后当数据更新后调用图表的绘制方法就可以了。就这么简单。","text":"前言最近的项目使用了 vue-chartjs 图表和 echarts 图表。昨天联调接口发现接口返回数据后，图表没有根据数据更新。还是默认数据渲染的图表。 排查确认了接口没问题和代码也没报错后。审查代码发现是图表的渲染是在 mounted 中执行的，而这个生命周期函数只执行一次，所以数据更新了，图表没有响应式更新也是正常的。本来还以为是要调用专门的 API 去刷新图表。 解决经过网上查找资料发现，其实只要使用 watch 检测数据，然后当数据更新后调用图表的绘制方法就可以了。就这么简单。 示例1234567891011121314151617181920212223242526272829303132333435363738394041 props: &#123; chartsData: &#123; type: Array, required: true, validator: function(value) &#123; return value.length &gt; 0; &#125; &#125;&#125;,computed: &#123; counts() &#123; let count = []; this.chartsData.forEach(item =&gt; &#123; count.push(item.allAmountTotalDay); &#125;); return count; &#125;, days() &#123; let day = []; this.chartsData.forEach(item =&gt; &#123; day.push(item.day); &#125;); return day; &#125;, // all 计算属性的用途是将需要 watch 的两个属性合并到一起再进行监测 all() &#123; return &#123; counts: this.counts, days: this.days &#125;; &#125; &#125;,watch: &#123; all(curVal) &#123; // 数据发生改变，便调用图表绘制方法传入最新数据绘制 this.drawLine(curVal.counts, curVal.days); &#125;&#125;,mounted() &#123; this.drawLine(this.counts, this.days);&#125;,methods: &#123; drawLine(counts, days) &#123;&#125;&#125; 总结将绘制方法定义在 methods 中便于复用，首先第一次在 mounted 中调用。然后使用 watch 属性监测处理过后的 chartsData ,数据改变时调用绘制方法，传入最新数据绘制。🆗 了。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-notification + mini-toastr 消息提示功能如何挂载到全局？","slug":"18.vue-notification + mini-toastr 消息提示功能如何挂载到全局？","date":"2020-04-16T17:00:00.000Z","updated":"2020-04-17T16:56:13.215Z","comments":true,"path":"2020/04/17/18.vue-notification + mini-toastr 消息提示功能如何挂载到全局？/","link":"","permalink":"http://yoursite.com/2020/04/17/18.vue-notification + mini-toastr 消息提示功能如何挂载到全局？/","excerpt":"前言最近的 coreui/vue 后台管理的项目中默认引入的是 vue-notification + mini-toastr 的消息提示，使用起来比着 element ui 麻烦一些，一开始翻了文档也没找到如何定义到全局。就每个文件重复定义。直到这两天突然有了灵感给解决了。 main.js 中初始化12345678910111213141516171819202122import VueNotifications from &quot;vue-notifications&quot;;import miniToastr from &quot;mini-toastr&quot;; // https://github.com/se-panfilov/mini-toastr// notificationsconst toastTypes = &#123; success: &quot;success&quot;, error: &quot;error&quot;, info: &quot;info&quot;, warn: &quot;warn&quot;&#125;;miniToastr.init(&#123; types: toastTypes &#125;);function toast(&#123; type, message, title, timeout, cb &#125;) &#123; return miniToastr[type](message, title, timeout, cb);&#125;const options = &#123; success: toast, error: toast, info: toast, warn: toast&#125;;// VueNotifications.setPluginOptions(options)Vue.use(VueNotifications, options);","text":"前言最近的 coreui/vue 后台管理的项目中默认引入的是 vue-notification + mini-toastr 的消息提示，使用起来比着 element ui 麻烦一些，一开始翻了文档也没找到如何定义到全局。就每个文件重复定义。直到这两天突然有了灵感给解决了。 main.js 中初始化12345678910111213141516171819202122import VueNotifications from &quot;vue-notifications&quot;;import miniToastr from &quot;mini-toastr&quot;; // https://github.com/se-panfilov/mini-toastr// notificationsconst toastTypes = &#123; success: &quot;success&quot;, error: &quot;error&quot;, info: &quot;info&quot;, warn: &quot;warn&quot;&#125;;miniToastr.init(&#123; types: toastTypes &#125;);function toast(&#123; type, message, title, timeout, cb &#125;) &#123; return miniToastr[type](message, title, timeout, cb);&#125;const options = &#123; success: toast, error: toast, info: toast, warn: toast&#125;;// VueNotifications.setPluginOptions(options)Vue.use(VueNotifications, options); 单文件引入1234567891011121314151617181920212223notifications: &#123; showSuccessMsg: &#123; type: &quot;success&quot;, message: &quot;success!&quot; &#125;, showErrorMsg: &#123; type: &quot;error&quot;, message: &quot;error&quot; &#125;&#125;,methods: &#123; onSubmit() &#123; if (Object.values(this.goodsData).indexOf(&quot;&quot;) !== -1) &#123; this.showErrorMsg(&#123; message: &quot;有必填项为空&quot; &#125;); return; &#125; if (this.goodsData.files.length === 0) &#123; this.showErrorMsg(&#123; message: &quot;请至少上传一张图片&quot; &#125;); return; &#125; // ....... &#125;&#125; 可以看到每个页面引入还是挺麻烦的。 挂载到全局定义：123456789101112131415161718192021222324const vm = new Vue(&#123; el: &quot;#app&quot;, router, template: &quot;&lt;App/&gt;&quot;, components: &#123; App &#125;, notifications: &#123; showSuccessMsg: &#123; type: &quot;success&quot;, message: &quot;success!&quot; &#125;, showErrorMsg: &#123; type: &quot;error&quot;, message: &quot;error&quot; &#125;, showInfoMsg: &#123; type: &quot;info&quot;, message: &quot;info&quot; &#125; &#125;&#125;);// 将 VueNotifications 挂载给全局， vm 实例上有消息提示方法Vue.prototype.$notice = vm 使用：12345methods: &#123; getMenus() &#123; this.$notice.showInfoMsg(&#123; message: &quot;菜单获取成功，$notice test&quot; &#125;); &#125;&#125; 这两天终于解决了这个问题，记录一下。可能有更简便的用法，有时间再研究下文档。哈哈哈","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"记一次 bug: '90' > '100' ??","slug":"17.记一次 bug：90大于100？？","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-17T16:56:07.395Z","comments":true,"path":"2020/04/17/17.记一次 bug：90大于100？？/","link":"","permalink":"http://yoursite.com/2020/04/17/17.记一次 bug：90大于100？？/","excerpt":"前言在最近的一次项目中遇到了一个小问题，就是进行提现操作时，明明提现金额小于可用总余额，却依旧提示输入的提取金额不合法（超出总余额）。 追根溯源经过排查，确认代码逻辑没有问题，问题出在比较的步骤。在做大小比较时，只记得基本类型比较时，== 不全等比较时，类型不一样会自动进行类型的隐式转换，然后只比较值是否一致。=== 全等类型比较时，会比较类型和值。而忽略了字符串同类型的比较是比较编码，而不是值。在排查问题时，很快想到了这个点，依稀记得这个知识点是从 arr.sort() 数组的排序方法得来的。","text":"前言在最近的一次项目中遇到了一个小问题，就是进行提现操作时，明明提现金额小于可用总余额，却依旧提示输入的提取金额不合法（超出总余额）。 追根溯源经过排查，确认代码逻辑没有问题，问题出在比较的步骤。在做大小比较时，只记得基本类型比较时，== 不全等比较时，类型不一样会自动进行类型的隐式转换，然后只比较值是否一致。=== 全等类型比较时，会比较类型和值。而忽略了字符串同类型的比较是比较编码，而不是值。在排查问题时，很快想到了这个点，依稀记得这个知识点是从 arr.sort() 数组的排序方法得来的。 实例验证123456789// 经查询资料，确认字符串比较是比较 Unicode 编码console.log(&apos;90&apos;&gt;&apos;100&apos;)// trueconsole.log(&apos;90&apos;&gt;100)// false// charCodeAt 获取指定位置的字符串的 Unicode 编码，默认取索引为 0 的第一位 console.log(&apos;90&apos;.charCodeAt())// Unicode 编码: 9 = 57console.log(&apos;100&apos;.charCodeAt())// Unicode 编码: 1 = 49// fromCharCode 将 Unicode 编码转回字符串console.log(String.fromCharCode(57))// 9console.log(String.fromCharCode(49))// 1 总结JS 基本类型的比较 === 比较值和类型，值和类型有一项不一致就是 false。 == 只比较值，类型不同时会做隐式的类型转换。 字符串数字比较 同为字符串数字时，会比较 unicode 编码大小，不会按值比较。切记。 一个字符串数字，一个 number 时，类型不一致，做隐式转换，再比较值。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript 常用数组方法整理","slug":"16. JavaScript 常用数组方法整理","date":"2020-04-12T16:00:00.000Z","updated":"2020-04-17T16:56:00.820Z","comments":true,"path":"2020/04/13/16. JavaScript 常用数组方法整理/","link":"","permalink":"http://yoursite.com/2020/04/13/16. JavaScript 常用数组方法整理/","excerpt":"1. arr.push() 释义：在数组的末尾添加一个或多个元素。 返回值：返回新的数组的长度。 语法：arr.push(元素1,元素2,...,元素x) 参数：元素1 必填，元素2 和元素x 可选。 说明：会改变原数组，并不会返回一个新数组。","text":"1. arr.push() 释义：在数组的末尾添加一个或多个元素。 返回值：返回新的数组的长度。 语法：arr.push(元素1,元素2,...,元素x) 参数：元素1 必填，元素2 和元素x 可选。 说明：会改变原数组，并不会返回一个新数组。 2. arr.pop() 释义：删除数组末尾最后一个元素。 返回值：返回被删除的元素。 语法：arr.pop() 参数：无。 说明：改变原数组，将数组长度减一。 注意：如果数组为空，则不改变原数组，会返回 undefined。3. arr.unshift() 释义：从数组的开头添加一个或多个元素。 返回值：返回新的数组长度。 语法：arr.unshift(元素1,元素2,...,元素x) 参数：元素1 必填，元素2 和元素x 可选。 说明：直接修改原数组，不创建新的数组。 注意：unshift() 方法无法在 Internet Explorer 中正确地工作！（待确认）4. arr.shift() 释义：从数组的开始删除第一个元素。 返回值：返回删除的元素。 语法：arr.shift() 参数：无。 说明：改变原数组，将数组长度减一。 注意：如果数组为空，则不改变原数组，会返回 undefined。5.arr.reverse() 释义：翻转数组。 返回值：返回处理好的数组。 语法：arr.reverse() 参数：无。 说明：直接修改原数组。6.arr.sort() 释义：数组排序 返回值：返回数组的引用。（待确认） 语法：arr.sort(sotrFn) 参数：该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 说明：直接修改原数组。 示例12arr.sort(function(x,y)&#123;return x-y&#125;);// 升序arr.sort(function(x,y)&#123;return y-x&#125;);// 降序 7.arr.splice() 释义：可实现对数组的删除、替换、添加操作。 返回值：返回被删除的数组。如果有的话。 语法：arr.splice(index,howmany,item1,.....,itemX) 参数： index：必填，删除，替换，添加操作的数组下标位置。使用负数的话，就从数组结尾算起。 howmany: 必填：要删除的数组元素个数，为 0 则不删除。 item1,…itemX: 可选，添加的元素。 说明：会修改原数组。 示例：12345678var arr = new arr(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);// 删除数组中的&quot;b&quot;// arr.splice(1, 1);// 将数组中的&quot;b&quot; 替换成 &quot;e&quot;// arr.splice(1, 1, &quot;e&quot;);// 在&quot;b&quot;的后面添加x, yarr.splice(2, 0, &quot;x&quot;, &quot;y&quot;);//从下标位置开始添加console.log(arr); 8.arr.slice() 释义：从数组中截取元素。 返回值：将截取出来的数组元素放在一个新数组中返回。 语法：arr.slice(start,end) 参数： start: 必须，起始索引，从 0 开始。如果为负数，-1为最后一个元素，-2为倒数第二个元素。 end: 可选，结束索引，从 1 开始。截取不包括 end。如果不传，则截取到数组末尾。如果为负数，则从数组末尾算起。 说明：不改变原数组。9.arr.indexOf() 释义：从前往后查找数组中的元素。 返回值：找到第一个就返回元素下标，不再查找。没找到返回 -1。 语法：arr.indexOf(元素，查找位置) 参数： 元素：必选，要查找的元素。 查找位置：可选，默认值为 0。如果索引大于或等于数组长度，则返回 -1。为负数时，依旧是从前往后查找。-1代表最后一个元素，-2为倒数第二个，以此类推。当索引小于 0 时，默认查询整个数组。10.arr.lastIndexOf() 释义：从后往前查找数组中的元素。 返回值：找到第一个就返回元素下标，不再查找。没找到返回 -1。 语法：arr.lastIndexOf(元素，查找位置) 参数： 元素：必选，要查找的元素。 查找位置：可选，默认值为数组最后一项的索引，即数组长度-1。如果索引大于或等于数组长度，则查询整个数组。为负数时，依旧是从后往前查找。“如果为负值，将其视为从数组末尾向前的偏移。”。当索引的绝对值大于数组长度时，返回 -1。 11.arr.concat() 释义：将多个数组拼接成一个数组。 返回值：返回拼接好的数组。 语法：arrayObj.concat(arr1,arr2,...,arrX) 参数： arrX: 必填，需要被添加进调用了 concat 方法的数组 arrayObj 中的项目。可以是具体的值，也可以是数组，当时数组时，是把数组的值添加进去 arrayObj。而不是直接添加数组。 说明：不会改变原数组。12.arr.join() 释义：将数组中的元素以某个字符进行拼接。 返回值：返回拼接好的字符串。 语法：arr.join(连接字符) 参数： 连接字符：默认为逗号。 说明：不会改变原数组。 注意：如果数组元素为undefined或null，则被视为空字符串。 示例：12var arr=[undefined,undefined,null,null];console.log(arr.join(&quot;|&quot;)); // ||| 13. arr.forEach() 释义：遍历数组。 返回值：undefined 语法：arr.forEach(function(value,index,array){},thisArg) 参数： function: value:当前循环到的元素 index:可选，当前元素的索引。 array:可选，被遍历的原数组。 thisArg: 如果 thisArg 参数有值，则每次 callback 函数被调用时，this 都会指向 thisArg 参数。如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。 说明：forEach 方法不会直接改变原数组，但可能被 forEach 方法的 callback 改变。14.arr.map() 释义：遍历数组。 返回值：进行遍历操作后的新的数组。 语法 var new_array = arr.map(function callback(currentValue[, index[, array]]) {// Return element for new_array}[, thisArg]) 参数：同 forEach 说明：map 方法不会直接改变原数组，但可能被 map 方法的 callback 改变。15.arr.filter() 释义：数组过滤。 返回值：返回过滤好的数组，没有符合的则返回空数组。 语法： var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) 参数： callcack: 过滤规则的回调函数 element: 当前元素。 index: 可选，当前元素的索引。 array: 可选：调用方法的数组。 thisArg: 可选，执行 callback 时，用于 this 的值。如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。 说明：不会改变原数组。16.arr.findIndex() 释义：根据回调函数查找索引 返回值：找到匹配元素后，返回索引，找到一个就停止查找。没找到返回 -1。 语法： arr.findIndex(callback[, thisArg]) 参数：同上。 示例：123var arr = [&apos;zs&apos;, &apos;ls&apos;, &apos;ww&apos;]var index = arr.findIndex(item =&gt; item === &apos;zs&apos;)console.log(index) 17. arr.every() 释义：测试数组的所有元素是否都通过了指定函数的测试。 返回值：和 &amp;&amp; (且)类似，都符合条件返回 true, 只要有一个不符合条件便返回 false。 语法：arr.every(callback[,thisArg]); 参数：同上。 说明：不会改变原数组。 注意：空数组也是返回 true（空数组中所有元素都符合给定的条件）。18. arr.some()和 every() 用法一样，只是采用 || (或)的运算规则。19. Array.isArray() 释义：用于确定传递进来的一个元素是不是数组。 返回值：是数组则为 true, 否则为 false。 语法：Array.isArray(obj) 参数：obj:需要检测的元素。 注意：直接由 Array 调用。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"js 数组","slug":"js-数组","permalink":"http://yoursite.com/tags/js-数组/"}]},{"title":"自己实现简单的函数防抖(debounce)和函数节流(throttle)","slug":"15.自己实现简单的函数防抖(debounce)和函数节流(throttle)","date":"2020-04-07T16:00:00.000Z","updated":"2020-04-17T16:55:47.299Z","comments":true,"path":"2020/04/08/15.自己实现简单的函数防抖(debounce)和函数节流(throttle)/","link":"","permalink":"http://yoursite.com/2020/04/08/15.自己实现简单的函数防抖(debounce)和函数节流(throttle)/","excerpt":"前言前端的交互中，有些操作需要持续触发，而且频率非常高。比如：resize, scroll, mousemove, input等事件。而为了性能和效率，我们不需要让事件触发太多次。这就诞生了函数的防抖和节流。 防抖(debounce)防抖简单说就是在设定的时间内，虽然操作上持续触发，通过定时器约束，我们也只执行函数触发的最后一次。 防抖函数可以分为延迟执行版和立即执行版 延迟执行版 12345678910111213141516171819/* fn: 需要防抖的函数 wait: 延迟毫秒数 return: 函数 */ // 延迟执行 function debounce(fn, wait) &#123; var timer; // 全局的定时器 id return function () &#123; var that = this; // 将函数被调用时的 this 保存 var args = arguments; // 保存函数的参数 if (timer) &#123; clearTimeout(timer); // 清除 wait 时间内频繁调用函数产生的定时器 &#125; timer = setTimeout(() =&gt; &#123; fn.apply(that, args); // 将传递进来的 fn 使用 apply 调用，将 this 指向改为保存的 that，同时进行传参 &#125;, wait); &#125;; &#125;","text":"前言前端的交互中，有些操作需要持续触发，而且频率非常高。比如：resize, scroll, mousemove, input等事件。而为了性能和效率，我们不需要让事件触发太多次。这就诞生了函数的防抖和节流。 防抖(debounce)防抖简单说就是在设定的时间内，虽然操作上持续触发，通过定时器约束，我们也只执行函数触发的最后一次。 防抖函数可以分为延迟执行版和立即执行版 延迟执行版 12345678910111213141516171819/* fn: 需要防抖的函数 wait: 延迟毫秒数 return: 函数 */ // 延迟执行 function debounce(fn, wait) &#123; var timer; // 全局的定时器 id return function () &#123; var that = this; // 将函数被调用时的 this 保存 var args = arguments; // 保存函数的参数 if (timer) &#123; clearTimeout(timer); // 清除 wait 时间内频繁调用函数产生的定时器 &#125; timer = setTimeout(() =&gt; &#123; fn.apply(that, args); // 将传递进来的 fn 使用 apply 调用，将 this 指向改为保存的 that，同时进行传参 &#125;, wait); &#125;; &#125; 立即执行版 123456789101112131415// 立即执行 function debounce(fn, wait) &#123; var timer; return function () &#123; var that = this; var args = arguments; if (timer) &#123; clearTimeout(timer); &#125; if (!timer) fn.apply(that, args); // 首次进入， timer 为空，执行 fn 函数 timer = setTimeout(() =&gt; &#123; timer = null; // wait 毫秒后设置 timer 为空 &#125;, wait); &#125;; &#125; 防抖应用场景 reseize 事件 按钮 click 控制 节流(throttle)节流就是按照给定的时间有规律的执行函数，可以通过时间戳和定时器实现。 节流函数可以分为定时器版和时间戳版 定时器版1234567891011121314// 定时器版 function throttle(fn, wait) &#123; let timer; return function () &#123; const that = this; const args = arguments; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(that, args); timer = null; &#125;, wait); &#125; &#125;; &#125; 时间戳版12345678910111213// 时间戳版 function throttle(fn, wait) &#123; let previous = 0; return function () &#123; const that = this; const args = arguments; let now = Date.now(); if (now - previous &gt; wait) &#123; fn.apply(that, args); previous = now; &#125; &#125;; &#125; 节流应用场景 元素拖动 搜索联想 移动端上滑加载时判断距离底部的位置","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"函数防抖和节流","slug":"函数防抖和节流","permalink":"http://yoursite.com/tags/函数防抖和节流/"}]},{"title":"使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？","slug":"14. 使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？","date":"2020-04-05T17:00:00.000Z","updated":"2020-04-17T16:55:17.926Z","comments":true,"path":"2020/04/06/14. 使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？/","link":"","permalink":"http://yoursite.com/2020/04/06/14. 使用 vue-cli 创建项目时，vue 的 'runtime-only' 是什么意思？/","excerpt":"前情提要这几天在使用 vue-cli 创建 vue 项目时，竟然忘记 runtime-only 运行时和 runtime + compiler 完整版的区别了，查过官网文档后，记下这篇笔记。 注：以下内容摘自官网。 runtime-only术语完整版：同时包含编译器和运行时的版本。 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 对于 Vue 不同构建版本的区别，可访问 Vue 官网查看 Vue 对不同构建版本的解释","text":"前情提要这几天在使用 vue-cli 创建 vue 项目时，竟然忘记 runtime-only 运行时和 runtime + compiler 完整版的区别了，查过官网文档后，记下这篇笔记。 注：以下内容摘自官网。 runtime-only术语完整版：同时包含编译器和运行时的版本。 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 对于 Vue 不同构建版本的区别，可访问 Vue 官网查看 Vue 对不同构建版本的解释 运行时 + 编译器 vs. 只包含运行时如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版： 12345678910// 需要编译器new Vue(&#123; template: &apos;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&apos;&#125;)// 不需要编译器new Vue(&#123; render (h) &#123; return h(&apos;div&apos;, this.hi) &#125;&#125;) 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"}]},{"title":"lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别","slug":"13. lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-17T16:55:08.644Z","comments":true,"path":"2020/04/06/13. lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别/","link":"","permalink":"http://yoursite.com/2020/04/06/13. lodash 的 _.debounce() 和 _.throttle() 以及函数防抖和函数节流的区别/","excerpt":"_.debounce() 和 _.throttle()防抖：语法 _.debounce(func, [wait=0], [options={}]) 创建一个防抖动函数。会从上一次调用结束后延迟 wait 毫秒后继续调用 func 方法，该函数提供一个 cancel 方法以供取消延迟函数的调用以及 flush 方法立即调用。 options 对象这个参数决定了怎么调用 func 函数。options.leading 与（或） options.trailing 决定延迟（wait）前，func 如何调用（也就是先调用再等待还是先等待再调用）。func 会传入最后一次传递的参数给 debounce 这个函数。随后调用的 debounce 函数返回的是最后一次 func 调用的结果。","text":"_.debounce() 和 _.throttle()防抖：语法 _.debounce(func, [wait=0], [options={}]) 创建一个防抖动函数。会从上一次调用结束后延迟 wait 毫秒后继续调用 func 方法，该函数提供一个 cancel 方法以供取消延迟函数的调用以及 flush 方法立即调用。 options 对象这个参数决定了怎么调用 func 函数。options.leading 与（或） options.trailing 决定延迟（wait）前，func 如何调用（也就是先调用再等待还是先等待再调用）。func 会传入最后一次传递的参数给 debounce 这个函数。随后调用的 debounce 函数返回的是最后一次 func 调用的结果。 注意：如果 leading 和 trailing 都为 true，则 func 允许的 trailing 调用条件为 wait 期间多次调用 debounce 防抖方法。如果 wait 为 0 并且 leading 为 false, func 调用将被推迟到下一个点，类似 setTimeout 为 0 的超时。 参数： func: 需要防抖的函数 wait(number): 毫秒数 opotions(object): 选项对象 options.leading(boolean): 调用在防抖开始前。 options.trailing(boolean): 调用在防抖结束后。 options.maxWait(number): 允许 func 被延迟的最大毫秒数。 返回值：返回新的防抖动函数。 示例代码请看官网：lodash 之 debounce 节流：语法 _.throttle(func, [wait=0], [options={}]) throttle() 方法创建一个节流函数，意为在 wait 秒内最多执行一次 func 函数。该函数同时提供一个 cancel 方法以供取消延迟函数的调用以及 flush 方法立即调用。 options 对象这个参数决定了怎么调用 func 函数。options.leading 与（或） options.trailing 决定延迟（wait）前，func 如何调用。func 会传入最后一次传递的参数给这个函数。随后调用的函数返回的是最后一次 func 调用的结果。 注意：如果 leading 和 trailing 都为 true，则 func 允许的 trailing 调用条件为 wait 期间多次调用。如果 wait 为 0 并且 leading 为 false, func 调用将被推迟到下一个点，类似 setTimeout 为 0 的超时。 参数： func: 需要节流的函数 wait(number): 毫秒数 opotions(object): 选项对象 options.leading(boolean): 调用在节流开始前。 options.trailing(boolean): 调用在节流结束后。 返回值：返回节流的函数。 123456789101112131415// 避免在滚动时过分的更新定位$(window).on(&quot;scroll&quot;, _.throttle(updatePosition, 500));function updatePosition() &#123; // 假装在更新定位 console.log(1);&#125;// 点击后就调用 renewToken， 但 5 分钟内超过一次var throttled = _.throttle(renewToken, 300000, &#123; trailing: false &#125;);$(ele).on(&quot;click&quot;, throttled);// 取消一个 trailing 的节流调用$(window).on(&quot;popstate&quot;, throttled.cancel);function renewToken() &#123; // 假装在请求更新 token console.log(2);&#125; _.debounce() 和 _.throttle() 的 api 介绍和使用方法取自官网，加了一点修饰。 防抖和节流的区别防抖:把突然爆发的事件(比如点击事件)组合成一个单一的事件。场景应用： 浏览器的 resize 事件，借助防抖我们只需要关注用户拖动窗口的最后一次的值。 比如用户输入内容时，使用防抖只在用户停止输入时触发事件。 类似的用例是等到用户停止输入之后再验证其输入值。 提示“您的密码太短”之类的消息。 节流：保证每 x 毫秒执行一次函数，它是恒定的流量。场景应用： 比如每 200 毫秒检查一次你的滚动位置来触发一个 CSS 动画。 比如上滑加载，我们需要检测用户距离底部多远，当用户接近底部时，我们需要发送 ajax 请求数据回来。在这里，防抖没用，因为它只在用户停止滚动时触发，而我们需要在用户到达底部之前获取数据。而节流可以让我们不停检测距离底部多远？节流可以保证函数有规律地执行，至少每 x 毫秒执行一次。 防抖和节流的区别总结和翻译自下面这篇文章，更多详细信息可访问 David Corbacho’s article 查看 _.debounce 函数防抖和 _.throttle 函数节流的区别 小技巧如果你只需要防抖和节流函数，您可以使用 Lodash 自定义构建器输出一个自定义的 2KB 最小化库。 用下面这个简单的命令构建它: 12npm i -g lodash-clilodash include = debounce, throttle","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"lodash","slug":"lodash","permalink":"http://yoursite.com/tags/lodash/"}]},{"title":"数组方法之reduce()","slug":"12. 数组方法之 reduce","date":"2020-04-04T17:50:09.000Z","updated":"2020-04-17T16:54:52.706Z","comments":true,"path":"2020/04/05/12. 数组方法之 reduce/","link":"","permalink":"http://yoursite.com/2020/04/05/12. 数组方法之 reduce/","excerpt":"reduce() 方法对数组的每个元素依次执行自定义回调函数，返回值为回调函数 return 的处理结果。先看一个示例： 1234const arr = [1, 2, 3, 4];const reduceFn = (accumulator, currentVal) =&gt; accumulator + currentVal;console.log(arr.reduce(reduceFn));// 10console.log(arr.reduce(reduceFn, 5));// 15","text":"reduce() 方法对数组的每个元素依次执行自定义回调函数，返回值为回调函数 return 的处理结果。先看一个示例： 1234const arr = [1, 2, 3, 4];const reduceFn = (accumulator, currentVal) =&gt; accumulator + currentVal;console.log(arr.reduce(reduceFn));// 10console.log(arr.reduce(reduceFn, 5));// 15 语法： arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数方法接收两个参数： callback() 回调函数。其接收四个参数： accumulator：累计器，累计回调函数的值。 current value：当前值。 current index： 当前值的索引。（可选） souce map: 源数组，也就是调用 reduce() 方法的数组。（可选） initVal: 初始值。（可选） 返回值回调函数累计处理的结果。 注意 如果传递 initVal，则 accumulator 累计器为 initVal, 不传递则为数组的第一项。 currentVal 当前值为数组第一项，不传递则为数组第二项。 currentIndex 当前索引为数组第一项的索引 0，不传递则为 1。 当给空数组调用 reduce 方法，且不传递初始值时，将报错。如果数组仅有一个元素，且没有提供初始值，或者提供了初始值，但数组为空，会将唯一值返回，并且 callback 不再执行。 更多 reduce 的使用示例可访问 MDN 之 reduce","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"JavaScript Array reduce","slug":"JavaScript-Array-reduce","permalink":"http://yoursite.com/tags/JavaScript-Array-reduce/"}]},{"title":"Vue.js 响应式的注意事项","slug":"11. Vue.js 响应式的注意事项","date":"2020-04-04T16:50:09.000Z","updated":"2020-04-17T16:54:38.158Z","comments":true,"path":"2020/04/05/11. Vue.js 响应式的注意事项/","link":"","permalink":"http://yoursite.com/2020/04/05/11. Vue.js 响应式的注意事项/","excerpt":"数组更新检测注意事项由于 JS 的限制，下列情形数组的更新不能被检测到。 使用数组下标设置一个数组项时 操作数组长度时 1234567var vm = new Vue(&#123; data: &#123; arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;&#125;)vm.arr[1] = &apos;x&apos;; // 不是响应式vm.arr.length = 2; // 不是响应式","text":"数组更新检测注意事项由于 JS 的限制，下列情形数组的更新不能被检测到。 使用数组下标设置一个数组项时 操作数组长度时 1234567var vm = new Vue(&#123; data: &#123; arr: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;&#125;)vm.arr[1] = &apos;x&apos;; // 不是响应式vm.arr.length = 2; // 不是响应式 对于第一种情况，可以使用 Vue.set() 方法和 vm.$set() 方法（vm.$set() 方法其实就是 Vue.set() 全局方法的别名）。同时可以使用 splice() 实现。 123Vue.set(vm.arr, 1, &apos;x&apos;)vm.$set(vm.arr, 1, &apos;x&apos;)vm.arr.splice(1, 1, &apos;x&apos;) 对于第二种情况也可以使用 splice() 方法实现。 1vm.arr.splice(2) 官网链接如下：数组更新方法-注意事项&gt;) 对象更新检测注意事项还是由于 JS 限制，Vue 不能检测对象属性的添加和删除。 12345678910var vm = new Vue(&#123; data: &#123; userInfo: &#123; name: &apos;简宝玉&apos; &#125; &#125;&#125;)// userInfo.name 响应式vm.userInfo.age = 17// userInfo.age 非响应式 同样，你可以使用 Vue.set() 和 vm.\\$set() 解决这个问题。 12Vue.set(vm.userInfo, age, 17)vm.$set(vm.userInfo, age, 17) 当你需要添加多个属性时，正确操作是使用 Object.assign() 或者 lodash 的 extend() 方法。 1234vm.userInfo = Object.assign(&#123;&#125;,vm.userInfo,&#123; age: 17, sex: &apos;男‘&#125;)","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Vue.js 之“变异”和“替换”的概念","slug":"10. Vue.js 之“变异”和“替换”的概念","date":"2020-04-04T16:35:18.000Z","updated":"2020-04-17T16:54:29.732Z","comments":true,"path":"2020/04/05/10. Vue.js 之“变异”和“替换”的概念/","link":"","permalink":"http://yoursite.com/2020/04/05/10. Vue.js 之“变异”和“替换”的概念/","excerpt":"前言今天在翻阅 Vue 的文档查看 watch 相关解释时，在查看到 vm.\\$watch 时看到了“变异”一词。官网内容摘抄如下： 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 当时内心充满了困惑，当真是不小的朋友也有很多问号？明明是我认识的词语，却又那么陌生。为了理解“变异”一词的意思，写下这篇文章。 什么是变异？ 变异方法，顾名思义，会改变调用了这些方法的原始数组。 数组的变异方法包括 push(), pop(), shift(), unshift(), splice(), sort(), reverse()。这些变异方法也会触发视图更新。","text":"前言今天在翻阅 Vue 的文档查看 watch 相关解释时，在查看到 vm.\\$watch 时看到了“变异”一词。官网内容摘抄如下： 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 当时内心充满了困惑，当真是不小的朋友也有很多问号？明明是我认识的词语，却又那么陌生。为了理解“变异”一词的意思，写下这篇文章。 什么是变异？ 变异方法，顾名思义，会改变调用了这些方法的原始数组。 数组的变异方法包括 push(), pop(), shift(), unshift(), splice(), sort(), reverse()。这些变异方法也会触发视图更新。 什么是替换？非变异方法也就是不会改变原数组，而总是返回一个新数组。例如：filter(), concat(), slice()等。当使用非变异方法时，可以直接替换数组。 1this.userList = this.userList.filter(item =&gt; item.age &gt; 18) 基于 Vue 的设计，这并不会导致整个列表被重新渲染，因而可以使用替换。 结语看到这里也就明白了，变异的情形就是变异方法会改变原数组。替换的情形就是非变异方法不改变原数组，返回新数组，加上 Vue 的设计，可以使用替换操作。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？","slug":"9. Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？","date":"2020-04-03T16:00:00.000Z","updated":"2020-04-17T16:52:32.964Z","comments":true,"path":"2020/04/04/9. Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？/","link":"","permalink":"http://yoursite.com/2020/04/04/9. Vue.js 的 computed 计算属性和 watch 侦听器的区别在哪里？/","excerpt":"为什么写这篇笔记？记得在以往的面试中多次被问到这个问题，回答的都不理想，仔细想想也是理解的不到位。今天借着休息的时间准备查阅文档，写写示例代码去仔细理解下。 computed 计算属性是什么？computed 计算属性介绍：computed 计算属性是一个对象。它的使用方法是在 computed 属性中定义一个方法，和给对象定义方法一样，方法名可以直接在页面（template）中使用，不需要加 （），这是因为计算属性看起来是指向了方法（function），其实指向的是方法 return 的结果。computed 计算属性的特性是计算结果会被缓存，如果 function 中依赖的响应式属性发生变化，computed 便会重新计算。注意如果依赖实例之外的属性（比如非响应式属性）则计算结果不会更新。此外，如果在计算属性中使用了箭头函数，则 this 不会指向组件的实例，但在函数中依然可以将实例以函数的第一个参数访问。如下： 123computed: &#123; aDouble: vm =&gt; vm.a * 2&#125;","text":"为什么写这篇笔记？记得在以往的面试中多次被问到这个问题，回答的都不理想，仔细想想也是理解的不到位。今天借着休息的时间准备查阅文档，写写示例代码去仔细理解下。 computed 计算属性是什么？computed 计算属性介绍：computed 计算属性是一个对象。它的使用方法是在 computed 属性中定义一个方法，和给对象定义方法一样，方法名可以直接在页面（template）中使用，不需要加 （），这是因为计算属性看起来是指向了方法（function），其实指向的是方法 return 的结果。computed 计算属性的特性是计算结果会被缓存，如果 function 中依赖的响应式属性发生变化，computed 便会重新计算。注意如果依赖实例之外的属性（比如非响应式属性）则计算结果不会更新。此外，如果在计算属性中使用了箭头函数，则 this 不会指向组件的实例，但在函数中依然可以将实例以函数的第一个参数访问。如下： 123computed: &#123; aDouble: vm =&gt; vm.a * 2&#125; 此外，计算属性默认只有 getter ，但也可以使用 setter 。具体操作示例请看 计算属性的 getter 和 setter 计算属性使用示例： 12345computed: &#123; newList: function() &#123; return this.brandList.filter(item =&gt; item.name.indexOf(this.keywords) !== -1); &#125; &#125; 什么时候使用计算属性？模板内表达式多用于简单计算，这样便于阅读代码时的理解。如果在模板表达式里使用复杂的运算，一是难以理解，二是不能复用。你可能会说，那我在 methods 中定义一个方法， return 处理结果也可以啊。是的，可以。但不同之处在于，计算属性会缓存计算结果，只在依赖的响应式属性发生变化时，才会更新数据。这是计算属性的性能优势。更多详情可访问 Vue 之 computed 属性 watch 侦听器是什么？watch 侦听器介绍watch 属性是一个对象，键（key)可以是 Vue 实例的表达式（字面量）和字符串（data 中定义的数据），值是回调函数，也可以是方法名、包含了方法的对象和方法集合的数组。回调函数的参数包含了新值和旧值。同时，如果需要对对象的值做进一步侦听，需要将键（key）对应的值设为对象，在对象的身上定义回调函数，再设置 deep 属性为 true。同时如果设置 immediate: true，则回调会在侦听开始之前调用。需要注意的是 watcher 函数不能是箭头函数，官网的解释是箭头函数绑定了父级作用域上下文，会使 this 不能按照期望指向 Vue 实例。 什么时候使用侦听器？当需要在数据变化时做异步或者开销比较大的操作时，watch 比较有用。 详细介绍可以访问 Vue 官网查看 watch 属性介绍。 Vue 之 watch 属性 总结：computed 计算属性和 watch 侦听器的区别相同点都是在数据发生变化需要进行处理的时候使用。 不同点 使用方式上计算属性是依据响应式属性得出的计算属性，使用时需要调用，且不加（），会缓存数据，在响应式属性更新时，计算属性也更新。侦听器不需要调用，会在侦听属性发生变化时，自动调用。注意，计算属性必须 return 一个结果，也就是处理后的计算属性的值。而侦听器则不需要。 使用场景上计算属性多用于依据一个或多个响应式属性得到另一个计算属性。比如：姓+名=全名。比如购物车结算金额时。侦听器多用于复杂场景或需要异步操作时，比如搜索时实时出现搜索建议或提示。搜索场景代码示例可访问Vue 之 侦听器。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"flex 布局之 \"flex: 1;\"","slug":"8. flex 布局之 flex 1","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-17T16:54:10.151Z","comments":true,"path":"2020/04/03/8. flex 布局之 flex 1/","link":"","permalink":"http://yoursite.com/2020/04/03/8. flex 布局之 flex 1/","excerpt":"flex: 1; 到底是什么意思？首先 flex 是 flex-grow, flex-shrink, flex-basis. 三个属性的简写，默认值为 0 1 auto。该属性有两个快捷值：auto(1 1 auto) 和 none(0 0 auto)。建议优先写 flex 属性，而不是写三个分离的属性，因为浏览器会自动计算其相关值。 flex-grow 默认为 0， 只能是正整数。即父元素有剩余空间也不放大元素。如果为 1，则把剩余空间的一份加给自己的宽度。 flex-shrink 默认为 1，只能是正整数。即父元素空间不足则按比例收缩。如果为 0，则不收缩 flex-basis 默认为 auto, 即元素本身的大小。这个属性定义了在分配多余空间之前，元素占据的主轴空间，浏览器根据这个属性计算是否有多余空间。可以设置为和 width 和 height 属性一样的值，比如 220px，则元素占据固定空间。 以上大部分是我初次学习 flex 布局记下的笔记内容。","text":"flex: 1; 到底是什么意思？首先 flex 是 flex-grow, flex-shrink, flex-basis. 三个属性的简写，默认值为 0 1 auto。该属性有两个快捷值：auto(1 1 auto) 和 none(0 0 auto)。建议优先写 flex 属性，而不是写三个分离的属性，因为浏览器会自动计算其相关值。 flex-grow 默认为 0， 只能是正整数。即父元素有剩余空间也不放大元素。如果为 1，则把剩余空间的一份加给自己的宽度。 flex-shrink 默认为 1，只能是正整数。即父元素空间不足则按比例收缩。如果为 0，则不收缩 flex-basis 默认为 auto, 即元素本身的大小。这个属性定义了在分配多余空间之前，元素占据的主轴空间，浏览器根据这个属性计算是否有多余空间。可以设置为和 width 和 height 属性一样的值，比如 220px，则元素占据固定空间。 以上大部分是我初次学习 flex 布局记下的笔记内容。 查阅笔记得知，flex 取值有两种情况。一是非负数字，二是长度或者百分比。当 flex 取非负数字时。比如 1 ，则该数字为 flex-grow 的值，flex-shrink 为 1 ，flex-basis 为 0%，则如下是等同的: 12345678.item &#123; flex: 1;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; _注_：当 flex-basis 取值为百分比时根据伸缩父容器的主尺寸计算，如果伸缩父容器的主尺寸没有定义（即父容器宽度取决于子元素）则计算结果和 auto 一样。 最终结果根据以上分析：flex: 1; 的值是 flex-grow: 1; flex-shrink: 1; flex-basis: 0%; 意思就是：元素占据剩余宽度的 1 份，收缩比例为 1，因为 flex-basis 具有最高优先级，元素首次分配宽度（flex-direction: colunm; 则为高度）如果父元素有设置宽度，则为 0%；父元素没有设置宽度，则和 auto 效果一致。 关于 flex 布局推荐下面一篇文章看，写的很好，今天写这篇博客搜到读之受益匪浅。 Flexbox，终于可以承认自己明白了","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://yoursite.com/tags/flex/"}]},{"title":"记一次bug：微信小程序真机调试访问接口失败","slug":"7. 记一次bug：微信小程序真机调试访问接口失败","date":"2020-04-02T07:53:00.000Z","updated":"2020-04-17T16:54:02.987Z","comments":true,"path":"2020/04/02/7. 记一次bug：微信小程序真机调试访问接口失败/","link":"","permalink":"http://yoursite.com/2020/04/02/7. 记一次bug：微信小程序真机调试访问接口失败/","excerpt":"一、开发情况简述：后端未部署，目前开发阶段直接连同事电脑，前端由我负责。 二、问题描述最近在使用 uni-app 开发微信小程序时，遇到了真机调试接口访问失败的问题。一开始草草的翻了官方文档，没看出个所以然。昨天在网上搜了一下原因，记得有网友提到了防火墙的问题。今天上午我试着关闭本机的防火墙后，还是不行。","text":"一、开发情况简述：后端未部署，目前开发阶段直接连同事电脑，前端由我负责。 二、问题描述最近在使用 uni-app 开发微信小程序时，遇到了真机调试接口访问失败的问题。一开始草草的翻了官方文档，没看出个所以然。昨天在网上搜了一下原因，记得有网友提到了防火墙的问题。今天上午我试着关闭本机的防火墙后，还是不行。 猛然间想到应该是要手机、电脑处于同一个网络下，我不记得昨天查的资料是否说了同一个网络的问题了，但想到去年秋天自己折腾 uni-app 开发安卓应用时，真机调试好像有要求手机和电脑处于同一个网络下。以前使用 appCan 开发应用时记得也是。然后使用 win10 系统自带的移动热点开启了一个无线网络给手机连接。 再次打开微信开发者工具的真机调试后，手机上运行小程序真的可以正常访问接口了。 but…测试一当我开启防火墙后，真机调试接口依然可以正常访问（访问正常的图就不贴了）。 测试二当我再次让手机和电脑处于同一个无线网下时，结果报错了。 三、结语根据实际测试得出如下结果： 需要关闭防火墙是真的，但是是由提供服务的后端同事关闭其电脑防火墙，之前遇到过这个问题，就是后端关闭防火墙解决的。前端其实无所谓。 处于同一个网络也是真的，但是是前端电脑和后端电脑及真机调试手机处于同一个网络下，这样服务可以正常访问，微信开发者工具的真机调试也才正常。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"http://yoursite.com/tags/BUG/"}]},{"title":"记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件","slug":"6. 记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件","date":"2020-04-01T05:45:23.000Z","updated":"2020-04-17T16:53:55.088Z","comments":true,"path":"2020/04/01/6. 记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件/","link":"","permalink":"http://yoursite.com/2020/04/01/6. 记一次 bug：gulp-uglify 在没有报错的情况下却没有压缩并输出部分文件夹里的 js 文件/","excerpt":"前言layuiAdmin pro 使用 gulp 构建源码时, controller 里的大部分文件夹里的 js 代码没有压缩输出，但也未报错。 问题详述 src/controller 目录结构如图：","text":"前言layuiAdmin pro 使用 gulp 构建源码时, controller 里的大部分文件夹里的 js 代码没有压缩输出，但也未报错。 问题详述 src/controller 目录结构如图： 执行 gulp 构建源码命令后的 dist/controller 目录结构如图，明显少了一些文件夹。 gulpfile.js 中调用 gulp-uglify 压缩 js 的代码如图： cmd 命令行中 gulp 命令执行结果截图： 原因排查排查过程 依据 layuiAdmin pro 文档，确认了 node 及 npm 没有问题，gulp 已全局安装，其依赖也已安装。 确认 layuiAdmin pro 中的 gulpfile.js 代码除了引入 babel 增加处理 ES6 的代码外，没有改变。 确认语法及 API 问题，经查阅资料:3.1 gulp.src() 中的路径 &#39;./src/**/*.js&#39; 没有错误，就是查找 src 下任意文件夹里的 js 文件。3.2 gulp.dest() 中文件输出路径没问题。3.3 uglify() 调用没有问题。3.4 gulp 引入等没有问题。 尝试升级 gulp-uglify 至最新版 3.0.2 没有作用。 依据 layuiAdmin pro 文档,确认是否由框架的缓存机制引起？虽然很可能应该无关，囧… 结论是没有用，无关缓存机制的事情。 尝试压缩某个具体文件 &#39;./src/controller/businessBasic/blackAndWhite/blackAndWhite.js&#39;， 也是无效。但是事情终于有了转机。 终于找到问题所在 点开这个未被压缩输出的文件发现是有语法错误，而问题仅仅是在 js 文件中使用了 html 的注释语法，继而导致文件没有被 gulp-uglify 正常压缩和输出。错误如图： 修正注释语法的错误后，终于可以正常压缩输出 js 文件了。 错误原因分析项目前端代码由后端同事兼职编写，后端同事对于前端技术不够熟悉，以至于使用了错误的注释语法，最终导致 js 文件没有被正确压缩输出。并且后端同事多使用 webstorm IDE，而 webstorm 没有提示注释语法错误。相反 vs code 有提示注释语法错误。 结语有时候低级的错误反而难以查找，就像功夫再高也怕菜刀和乱拳打死老师傅。相信专业的人做专业的事情，避免低级错误。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"http://yoursite.com/tags/BUG/"}]},{"title":"Vue 和 React 的异同","slug":"5. Vue 和 React 的异同","date":"2018-11-22T01:55:00.000Z","updated":"2020-04-17T16:51:31.730Z","comments":true,"path":"2018/11/22/5. Vue 和 React 的异同/","link":"","permalink":"http://yoursite.com/2018/11/22/5. Vue 和 React 的异同/","excerpt":"","text":"相同点 都有虚拟 DOM，都有组件概念，都有自己的构建工具，都有自己的 Chrome 调试工具，都支持服务端渲染，都是数据驱动视图。 都通过 props 参数进行父子组件的数据传递。 不同点 Vue 使用普通的 HTML 书写页面结构。而 React 使用 JSX 书写页面结构，也就是在 JS 中书写 HTML 。（从技术上来说，Vue 也支持 render 函数和 JSX 语法。） Vue 文档友好，相对简单易学，便于整合现有系统，不需要整体重构。而 React 文档是英文的，组件更多靠 JS 实现。 Vue 由尤雨溪的团队维护，React 由 Facebook 官方维护。vue-router 和 vuex 由 Vue 官方维护，而 react-router 和 react-redux 由社区成员维护。 Vue 使用 data 属性保存数据，而 React 使用 state 对象保存数据，state 对象要使用 setState() 方法改变状态。 Vue 构建移动应用的 weex 仍处于开发试验阶段，不够完善，而 React Native 更加成熟强大。 Vue 会追踪每个组件的状态，不会重新渲染整个组件树，而 React 会重新渲染所有的子组件，所以 React 有 shouldComponentUpdated 生命周期函数去控制。 Vue 使用单文件创建组件，而 React 使用 JSX + 行内样式创建组件。 Vue 支持双向数据绑定，而 React 是单向数据流，需要自己去模拟实现。","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"Vue React","slug":"Vue-React","permalink":"http://yoursite.com/tags/Vue-React/"}]},{"title":"ECMAScript 关键字整理（部分）","slug":"4. ECMAScript 关键字整理","date":"2018-04-23T12:31:00.000Z","updated":"2020-04-17T16:51:04.550Z","comments":true,"path":"2018/04/23/4. ECMAScript 关键字整理/","link":"","permalink":"http://yoursite.com/2018/04/23/4. ECMAScript 关键字整理/","excerpt":"ECMAScript 关键字 function解释：function 关键字用于创建一个函数。语法： 123function()&#123;&#125; this解释：this 关键字在 js 中是指当前行为执行的主体。 this 指向 普通函数调用，this 指向 window 。注意：严格模式（’use strict’）下，this 指向 undefined 。 构造函数中 this 指向构造函数实例化出来的对象，原型方法中的 this 也是指向实例化对象。 方法调用中 this 指向调用该方法的对象。 事件处理函数中的 this 指向触发事件的对象（事件源）。 定时器中的 this 指向 window 。 new解释：new 关键字用于搭配构造函数创建实例化对象。 new 关键字执行过程 创建空对象。 让 this 指向空对象。 执行构造函数，给创建的新对象添加属性和方法。 返回对象给函数的调用者。 return解释：return 关键字用于函数中，使用 return 可以返回需要返回的值，return 后面可以是任意的 js 数据类型。return 后面不写数据会返回 undefined 。return 后面的代码不再执行，直接结束函数。return 关键字作用范围是函数内。语法： 123function()&#123; return;&#125;","text":"ECMAScript 关键字 function解释：function 关键字用于创建一个函数。语法： 123function()&#123;&#125; this解释：this 关键字在 js 中是指当前行为执行的主体。 this 指向 普通函数调用，this 指向 window 。注意：严格模式（’use strict’）下，this 指向 undefined 。 构造函数中 this 指向构造函数实例化出来的对象，原型方法中的 this 也是指向实例化对象。 方法调用中 this 指向调用该方法的对象。 事件处理函数中的 this 指向触发事件的对象（事件源）。 定时器中的 this 指向 window 。 new解释：new 关键字用于搭配构造函数创建实例化对象。 new 关键字执行过程 创建空对象。 让 this 指向空对象。 执行构造函数，给创建的新对象添加属性和方法。 返回对象给函数的调用者。 return解释：return 关键字用于函数中，使用 return 可以返回需要返回的值，return 后面可以是任意的 js 数据类型。return 后面不写数据会返回 undefined 。return 后面的代码不再执行，直接结束函数。return 关键字作用范围是函数内。语法： 123function()&#123; return;&#125; for解释：for 关键字用于创建一个 for 循环。语法： 123for()&#123;&#125; if解释：if 关键字和 else 一起用于创建一个 if else 分支语句。语法： 12345if()&#123;&#125;else&#123;&#125; else解释：一般搭配 if 使用 while解释：while 关键字用于创建一个 while 循环。语法： 123while()&#123;&#125; do解释：do 关键字 和 while 一起用于创建一个 do while 循环。语法： 123do&#123; &#125;while() switch解释：switch 关键字用于创建一个 switch 分支语句。语法： 123456switch (key) &#123; case value: break; default: break;&#125; case解释：一般搭配 switch 使用 default解释：一般搭配 switch 使用 break解释：break 关键字在循环中是结束整个循环，继续执行循环后的代码。在 switch 中是阻止代码向下执行，跳出 switch 语句。break 关键字的作用范围是循环和 switch 语句内。语法： 123for() &#123; break;&#125; continue解释：continue 关键字用于结束当前的这一次循环，continue 之后的代码不再执行，继续下一次循环。其作用范围循环内。语法： 123for()&#123; continue;&#125; var解释：var 关键字用于声明一个变量。语法： 1var str = &apos;hello world&apos;; typeof解释：typeof 关键字用于获取变量的类型。会返回具体的数据类型，这个返回值是字符串类型的。注意：typeof 只能区分出基本数据类型和函数，不能区分出对象和数组。语法： 1typeof 变量 instanceof解释：instanceof 关键字用于判断 Object.prototype 是否出现在某个对象的原型链上。简单来说就是用于检测某一个实例对象是否属于某一个构造函数，返回布尔值。 in解释：in 关键字用于判断一个属性是否在一个对象中。有就返回 true ，没有返回 false 。语法： 1in 的是左边字符串，右边是对象 delete解释：delete 关键字用来删除一个非 var 声明的全局变量。或者删除对象里面的某一个属性。或者删除数组里的某一项。删除成功返回 true ， 失败返回 false 。 void解释：void 关键字用来表示不访问数据，可以阻止 a 标签的默认跳转行为。用在 a 标签中 ，href=“javascript:void(0)”。语法： 1&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; throw解释：throw 关键字用于抛出异常。 catch解释：catch 关键字用于捕获异常。常与 try、finally 配合使用。 try解释：一般搭配 catch 使用 finally解释：一般搭配 catch 使用 with解释：更新当前作用域。 参考资料W3scool 之 ECMAScript 关键字","categories":[{"name":"编程","slug":"program","permalink":"http://yoursite.com/categories/program/"}],"tags":[{"name":"JavaScript ECMAScript","slug":"JavaScript-ECMAScript","permalink":"http://yoursite.com/tags/JavaScript-ECMAScript/"}]},{"title":"我的设计作品","slug":"3. 我的设计作品","date":"2017-04-25T12:08:32.000Z","updated":"2020-04-17T16:50:17.889Z","comments":true,"path":"2017/04/25/3. 我的设计作品/","link":"","permalink":"http://yoursite.com/2017/04/25/3. 我的设计作品/","excerpt":"","text":"本人喜欢前端开发，大学专业是软件工程（数字多媒体方向），对设计方面略懂一点，也比较热爱骑行。上图是我以前为我们学校的骑行车队——周师如风车队（非官方组织）设计的队旗，Logo 部分有借鉴一位网友的设计。","categories":[{"name":"设计","slug":"design","permalink":"http://yoursite.com/categories/design/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"Web 前端的发展现状及未来机遇","slug":"2. Web 前端的发展现状及未来机遇","date":"2017-04-23T10:43:17.000Z","updated":"2020-04-17T16:50:09.093Z","comments":true,"path":"2017/04/23/2. Web 前端的发展现状及未来机遇/","link":"","permalink":"http://yoursite.com/2017/04/23/2. Web 前端的发展现状及未来机遇/","excerpt":"Web 前端的历史Web 前端的由来&emsp;&emsp;1991 年 8 月，Tim Berners-Lee 发布了第一个简单的，基于文本，包含几个链接的网站。但此后的网站发展一直很缓慢，这是因为早期的网页完全由单调的文本和图片所构成，对人们而言，毫无吸引力。到了 2005 年，互联网开始进入 Web2.0 时代，各种类似桌面软件的 Web 应用开始大量涌现，由此，网站建设发生了巨大的变革。与此同时，“前端”这个词开始在国内逐渐流行开来。 什么是前端&emsp;&emsp;我们一直说前端，但什么是前端呢？前端可以笼统的解释为凡是通过浏览器把内容呈现给用户的统称为前端。相反贮存于服务器端的则统称为后端。&emsp;&emsp;前端这个词是从网页制作演变过来的，名称上有着明显的时代特征。在互联网的演化过程中，网页制作是 Web1.0 时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。在这个阶段，网站的内容主要是文字和图片为主，制作方法也主要是使用 table 和 ASP。后来发展到使用 HTML、CSS、JavaScript 等前端技术构建页面。到现在，前端技术已经发展到 HTML5、CSS3、EcmaScript6 等，以后也会继续发展、继续完善。&emsp;&emsp;Web 前端虽然起步时间晚，但是发展势头迅猛，在各种新技术、新标准的推动下，各大互联网公司也开始重视 Web 产品的前端重构与开发，如淘宝、腾讯、新浪、百度、搜狐等都对自己的网站进行了重构并同时使用了 HTML5 中的新特性。现在开发的 Web 新产品的页面交互也越来越丰富，视觉效果也越来越绚丽。互联网公司除了重视前端开发之外，还在积极推动互联网技术的发展，2001 ～ 2012 年，腾讯、百度及奇虎 360 公司先后加入了万维网联盟（W3C），共同参与互联网技术标准的研究和制定，促进了国内互联网产业的发展。","text":"Web 前端的历史Web 前端的由来&emsp;&emsp;1991 年 8 月，Tim Berners-Lee 发布了第一个简单的，基于文本，包含几个链接的网站。但此后的网站发展一直很缓慢，这是因为早期的网页完全由单调的文本和图片所构成，对人们而言，毫无吸引力。到了 2005 年，互联网开始进入 Web2.0 时代，各种类似桌面软件的 Web 应用开始大量涌现，由此，网站建设发生了巨大的变革。与此同时，“前端”这个词开始在国内逐渐流行开来。 什么是前端&emsp;&emsp;我们一直说前端，但什么是前端呢？前端可以笼统的解释为凡是通过浏览器把内容呈现给用户的统称为前端。相反贮存于服务器端的则统称为后端。&emsp;&emsp;前端这个词是从网页制作演变过来的，名称上有着明显的时代特征。在互联网的演化过程中，网页制作是 Web1.0 时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。在这个阶段，网站的内容主要是文字和图片为主，制作方法也主要是使用 table 和 ASP。后来发展到使用 HTML、CSS、JavaScript 等前端技术构建页面。到现在，前端技术已经发展到 HTML5、CSS3、EcmaScript6 等，以后也会继续发展、继续完善。&emsp;&emsp;Web 前端虽然起步时间晚，但是发展势头迅猛，在各种新技术、新标准的推动下，各大互联网公司也开始重视 Web 产品的前端重构与开发，如淘宝、腾讯、新浪、百度、搜狐等都对自己的网站进行了重构并同时使用了 HTML5 中的新特性。现在开发的 Web 新产品的页面交互也越来越丰富，视觉效果也越来越绚丽。互联网公司除了重视前端开发之外，还在积极推动互联网技术的发展，2001 ～ 2012 年，腾讯、百度及奇虎 360 公司先后加入了万维网联盟（W3C），共同参与互联网技术标准的研究和制定，促进了国内互联网产业的发展。 Web 前端的技术与责任Web 前端技术&emsp;&emsp;Web 前端技术包括三个要素：HTML、CSS 和 JavaScript。 HTML（HyperText Markup Language）指超文本标记语言，是目前 Web 领域应用最广泛的标记语言，用来书写网页结构。CSS（Cascading Style Sheets）指层叠样式表，可以用来美化网页，也称为网页的表现层。而 JavaScript 则是网页的行为层，它可以用来书写页面交互效果。构建网页的一个最重要原则就是“结构、样式、行为”三层分离。 Web 前端的责任&emsp;&emsp;Web 前端工程师的主要职责是利用 HTML、CSS 书写符合 Web 标准的语义化代码来搭建网页，通过 JavaScript 来实现网页交互功能，致力于通过技术改善用户体验。Web 前端，往后是技术，往前是体验。Web 前端工程师既要与项目下游的服务器端工程师沟通，又要与项目上游的交互设计师、UI 设计师和产品经理沟通，需要掌握的技能非常多。这就从知识的广度上对 Web 前端开发工程师提出了要求。&emsp;&emsp;随着人们生活水平的提高，用户体验变得比以往更重要，而 Web 前端是后端数据的第一消费者，也是最贴近用户的程序员，因此提升用户体验是 Web 前端工程师的重要责任。 Web 前端的发展现状行业的发展现状&emsp;&emsp;第一，供求关系的不平衡。2015 年创业公司如雨后春笋一般冒了出来，而 2016 年下半年开始，更多的创业公司开始倒闭。与各个创业公司拔地而起同时发生的，还有大批其他行业工作者涌入 Web 前端这个当前比较火爆的行业。“公司数量的变化”与“大量从业者的涌入”这两点直接影响着供求关系。在当前以及未来的一段时间之内，会呈现典型的“供大于求”的行业状态；&emsp;&emsp;第二，前端行业日益成熟。在最初前端行业刚刚起步之时，各类的内容、功能都不够完善，需要大量的人去做“重复的事”，也需要不少人去研究和探索新的事物和技术。随着前端行业逐渐走向成熟，前端当中的主流框架层出不穷，除了最为经典的 jQuery 之外，还有 VUE、React、Angular 等等。当下，“前端”已经开始步入模块化、工程化，曾经大量繁琐而复杂的工作逐渐被模板或工具所替代。&emsp;&emsp;当一个行业日益成熟，势必会降低行业中的重复性工作，一个工作者在同一时间内完成的工作量也会大大增加，那么所需要的工作者数量自然会有所下降。整个 Web 前端行业之后将会进入一种趋于稳定发展的状态。 Web 前端开发体会&emsp;&emsp;Web 前端开发是一个较新的职业，它是在 Web2.0 的热潮下成长起来的，要求开发者掌握较综合的技能，除了必要的软件开发技术，还要对可用性有一定的了解，而又对设计有一定要求，因此，对于数字多媒体技术专业的学生来说，有着天然的优势，是最适合不过的职业之一。&emsp;&emsp;但是对于数字多媒体技术专业的学生，如果要在未来的就业中掌握主动权，单靠专业优势是远远不够的，还需要有深厚的技术功力，例如 HTML + CSS 技术，是必须要完全掌握精通的，JavaScript 更是要不断深耕细作，在专业达到一定的深度后，才有能力在工作中游刃有余，所向披靡。&emsp;&emsp;同时，在学习研究的过程中，要不断增加自己的项目经验，为自己增加筹码，由于前端开发行业的特殊性，数字媒体技术的学生在大三就可以开始在社会中寻找工作经验了，一些学校项目，工作室项目，社会兼职实习等，都是这些经验的重要来源。Web 前端开发是需要在不断实践中学习的，拥有一定的项目经验，才能在学习中得以扩展深入，否则很多单纯意义上的学习更像纸上谈兵，没有意义。 浏览器发展对 Web 前端的重要影响&emsp;&emsp;在 Web 前端发展的过程中，浏览器的发展起着至关重要的作用。浏览器厂商在这场 Web 浪潮中表现突出，具体表现在浏览器的版本升级周期短、对前端标准的支持也越来越好、浏览器的性能也有大幅的提升等。IE 浏览器也开始发力，最新发布的 IE 11 浏览器无论是标准的支持还是性能都比以往表现更好。浏览器的快速发展使得低端的浏览器如 IE 6、IE 7 等慢慢退出市场。&emsp;&emsp;2006 年，John Resig 开发的基于 JavaScript 的 jQuery 框架发布，其最大的突破在于让老旧浏览器适配新的 Web 标准，jQuery 框架从某种意义上解决了 PC 端浏览器兼容性的问题。&emsp;&emsp;目前，移动设备的普及率极高，用户已经逐渐习惯于通过移动设备来浏览网页。主流的移动平台主要为 Android 和 iOS 系统，对应的浏览器内核都是 WebKit，性能和对标准的支持都不错，这恰好也是移动 Web 应用的发展机遇。 Web 前端面临的挑战&emsp;&emsp;Web 前端技术也面临一些挑战。如今大量旧的网站需要重构来提高网站用户体验和性能，这些网站的前端代码普遍存在的问题有：代码没有实现三层分离，代码不够简洁高效，页面布局随意，网站整体性能差，不利于后期维护。 Web 前端的未来机遇Web 前端的发展方向&emsp;&emsp;新标准的进化与稳定。目前前端三层结构已经形成了 HTML5、CSS3、EcmaScript6 标准规范结合的阶段，后面标准的新变化也会越来越小，至少迄今为止，我们无法预见 HTML6 的到来、CSS4 的特性目前也令人担忧、EcmaScript7 的特性更新也并不明显，这都显示出，目前前端项目实践规范将会相对稳定一段较长的时间，后面的修改不会像之前一样具有颠覆性，这也是技术标准发展到一定成熟阶段会发生的事情。&emsp;&emsp;持续不断的技术工具探索。前端技术效率和性能的提升当然不是仅靠前端框架就能解决的，还需要其他各方面辅助工具的支持，比如高效的调试工具、构建自动化工具等。所以未来前端发展过程中各种高效工具的探索仍会不断地出现，来解决特定场景下的问题，最后进行优胜劣汰。&emsp;&emsp;前端新领域的出现。除了目前浏览器、服务器、移动端上的应用开发技术变革和探索外，未来前端也会出现新的应用场景。比如 VR、物联网 Web 化、Web 人工智能等。这些虽然听着比较远，但一旦到来就会很快被使用，所以前端不仅自身发展快，推广使用也极其迅速，例如移动互联网 Web 的普及也就两三年时间。 近几年，Web VR 和物联网 Web 化的概念渐渐出现，国外甚至出现了以人工智能为支撑的 Web 应用。 前端的繁荣值得期待&emsp;&emsp;Web 前端技术的发展日新月异，现在业内已经开始提出 Web3.0 的概念。最常见的解释是，网站内的信息可以直接和其他网站相关信息进行交互，能通过第三方信息平台同时对多家网站的信息进行整合使用；用户在互联网上拥有自己的数据，并能在不同网站上使用；完全基于 Web，用浏览器即可实现复杂系统程序才能实现的系统功能；用户数据审计之后，同步于网络数据。&emsp;&emsp;现在的 Web 前端开发越来越注重用户体验。无论底层技术的支持上，还是跨平台兼容的需求上，都为迎来前端的繁荣局面做好了准备。预计前端主导的产品会越来越多，前端工程师的位置会越来越重要。最后引用乔布斯的话，“Web 就是未来”。我们作为前端开发工作者也是未来。相信 Web 前端的明天会更好。 附录：参考书籍和文章《Web 前端开发最佳实践》 –党建 2015 年 1 月 《聊聊未来的前端时代》 –ouven 2016 年 12 月 11 日 《HTML5 行业现状与未来 - 2016 年终大盘点》 2017-01-20 19:03","categories":[{"name":"文章","slug":"文章","permalink":"http://yoursite.com/categories/文章/"}],"tags":[{"name":"前端","slug":"frontEnd","permalink":"http://yoursite.com/tags/frontEnd/"}]},{"title":"Hello World","slug":"1. hello-world","date":"2017-04-09T16:00:00.000Z","updated":"2020-04-17T16:49:38.084Z","comments":true,"path":"2017/04/10/1. hello-world/","link":"","permalink":"http://yoursite.com/2017/04/10/1. hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}